<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="." />




<meta name="author" content />


<meta name="description" content=".">

<script id="pandoc-meta" type="application/json">
{"author":"","date":"","knit":"pagedown::chrome_print","main-color":"#6BA09D","mathjax":"<a href=\"https://d3eoax9i5htok0.cloudfront.net/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\" class=\"uri\">https://d3eoax9i5htok0.cloudfront.net/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML</a>","newpage_html_class":"page-break-after","output":{"pagedreport::paged_windmill":{"front_img":"informe_portadas/portada_trim_x_organismo-1.png","img_to_dark":false,"logo":"","logo_to_white":false,"other_css":"estilo_reporte.css"}},"params":{"periodo":"param_fecha","sujeto_obligado":"param_so"},"subtitle":"- Agencia Federal de Inteligencia","title":"."}
</script>

<title>.</title>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  let beforePaged = PagedConfig.before;
  window.PagedConfig.before = async () => {
    if (beforePaged) await beforePaged();
    return new Promise((resolve, reject) => {
      var script = document.createElement("script");
      script.type = "text/javascript";
      var src = `https://mathjax.rstudio.com/latest/MathJax.js` + "?config=TeX-MML-AM_CHTML";
      if (location.protocol !== "file:" && /^https?:/.test(src))
        src = src.replace(/^https?:/, '');
      script.src = src;
      window.MathJax = {
        AuthorInit: () => {
          MathJax.Hub.Register.StartupHook("Begin", () => {
            MathJax.Hub.Queue(resolve);
          });
        }
      };
      document.getElementsByTagName("head")[0].appendChild(script);
    });
  };
})();
</script>

<link id="front-cover-1-pagedown-attachment" rel="attachment" href=" " />
<link id="back-cover-1-pagedown-attachment" rel="attachment" href=" " />
<link href="data:image/png;base64,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" id="front-cover-2-pagedown-attachment" rel="attachment" />
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: theres no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, []
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), []
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), []
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, []
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), []
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            
	//             head 
	//                            tail
	//                                         
	//                                                 
	//            item        item        item        item
	//                      
	//  null prev prev prev prev 
	//           next next next next null
	//                      
	//           data      data      data      data 
	//                      
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	//  4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	//  4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	//  4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	//  4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	//  4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// 4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// 4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	//  4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-' : node.min) +
	                ',' +
	                (node.max === null ? '' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    //  4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    //  4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If strings value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    //  4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>s value.
	            }
	        }
	    }

	    //  4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that its being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldnt be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    //  4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that propertys value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if anyfor example by saying that any pre-defined keywords
	    // in that propertys value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: its defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesnt matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// 5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	//  5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// 5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integers sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // 
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation[min,max]within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [,] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null  stashing allowed, nothing stashed
	    // false  stashing disabled, nothing stashed
	    // anithing else  fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   sources entry.  This value is prepended to the individual
	    //   entries in the source field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   sourceRoot, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,]>"
		},
		"positive-integer": {
			syntax: "<integer [0,]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // 2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the boxs intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>




<style type="text/css">
h1.title {
opacity: 0;
}
h1.subtitle {
font-size: 35px !important;
margin-top: 500px !important;
margin-left: -10px !important;
}
h2 {
font-size: 25px !important;
}
body {
font-size: 12pt !important;
text-align: justify !important;
text-align-last: left !important;
-moz-text-align-last: left !important;
}

.gt_table {
text-align-last: auto !important;
}
p, ul, ol {
margin-right: 1% !important;
}

@page:left {

@bottom-right {
content: counter(page);
color: var(--main-color);
border: 0 !important; margin-left: 20cm;
margin-right: -3cm;
padding-left: 1cm;
padding-right: 3cm;
margin-bottom: 0cm;
font-size: 14pt;
font-weight: bold;
}
}
@page:right {

@bottom-left {
content: counter(page);
color: var(--main-color);
border: 0 !important; margin-left: 20cm !important;
margin-right: -3cm !important;
padding-left: 1cm !important;
padding-right: 3cm !important;
margin-bottom: 1cm !important;
font-size: 14pt !important;
font-weight: bold !important;
}
}</style>
<style type="text/css">



:root {
--background: whitesmoke;
--pagedjs-width: 210mm;
--pagedjs-height: 297mm;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
--main-color: #c78039;
--main-font: "Gelasio";
--header-font: "Inter";
}


@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}


@page {
size: 210mm 297mm; 
}

h1.title {
string-set: h1-title content(text);
}
.shorttitle1 {
string-set: h1-text content(text);
}

@page {
@top-left-corner {
content: "";
border-bottom: 5px solid var(--main-color);
margin-bottom: 0.7cm;
}
@top-left {
content: string(h1-title);
font-family: "Inter";
font-weight: bold;
color: var(--main-color);
border-bottom: 5px solid var(--main-color);
margin-bottom: 0.7cm;
}
@top-center {
content: "";
border-bottom: 5px solid var(--main-color);
margin-bottom: 0.7cm;
}
@top-right {
content: string(h1-text);
font-family: "Inter";
color: var(--main-color);
border-bottom: 5px solid var(--main-color);
margin-bottom: 0.7cm;
}
@top-right-corner {
content: "";
border-bottom: 5px solid var(--main-color);
margin-bottom: 0.7cm;
}
}

@page:left {

@bottom-right {
content: counter(page);
color: var(--main-color);
border: 5px solid var(--main-color);
margin-left: 15cm;
margin-right: -3cm;
padding-left: 1cm;
padding-right: 3cm;
margin-bottom: 1cm;
font-size: 14pt;
font-weight: bold;
}
}
@page:right {

@bottom-left {
content: counter(page);
color: var(--main-color);
border: 5px solid var(--main-color);
margin-right: 15cm;
margin-left: -3cm;
padding-right: 1cm;
padding-left: 3cm;
margin-bottom: 1cm;
font-size: 14pt;
font-weight: bold;
}
}

@page:first{
background-color: #ffffff;
background-image: var(--front-cover), var(--front-cover-2);
background-repeat: no-repeat, no-repeat;
background-position: 15cm 23cm, 0cm 0cm;
background-size: 4cm, cover;
@top-left-corner {
display: none;
}
@top-left {
display: none;
}
@top-center {
display: none;
}
@top-right {
display: none;
}
@top-right-corner {
display: none;
}
@bottom-right {
display: none;
}
@bottom-left {
display: none;
}
}

@page back-cover {
margin: 0 0 0 0;
background-color: var(--main-color);
background-image: var(--back-cover);
background-repeat: no-repeat;
background-position: 15cm 23cm;
background-size: 4cm;
}
.back-cover {
page: back-cover;
}

@font-face {
font-family: 'Gelasio';
font-style: normal;
font-weight: 400;
src: url(data:font/ttf;base64,AAEAAAAQAQAABAAAR0RFRiWOHfgAAAJAAAAA8kdQT1Nt1YfZAAAbHAAACJpHU1VCi2ODxwAAD4QAAAUiT1MvMmaQMLoAAAHgAAAAYFNUQVTneswGAAABmAAAAEhjbWFwoTWczQAAB9wAAALMZ2FzcAAAABAAAAEUAAAACGdseWbAREp2AAAjuAAAd9hoZWFkKZIt6wAAAWAAAAA2aGhlYQ6ZA38AAAE8AAAAJGhtdHj5uViAAAAKqAAABNxsb2Nhge6gQQAABWwAAAJwbWF4cAFEAP0AAAEcAAAAIG5hbWUwn1gJAAADNAAAAjZwb3N0Jo2CXQAAFKgAAAZxcHJlcGgGjIUAAAEMAAAAB7gB/4WwBI0AAAEAAf//AA8AAQAAATcAkAAFAGsABAABAAAAAAAAAAAAAAAAAAMAAQABAAAHbP1EAAAIZv6s/J0IfgABAAAAAAAAAAAAAAAAAAABNwABAAAAAQIMH1NFFl8PPPUAAwgAAAAAAOGB9JIAAAAA4c7s2f6s/bEIfgfIAAAABgACAAAAAAAAAAEAAQAIAAIAAAAUAAIAAAAkAAJ3Z2h0AQAAAGl0YWwBBQABABQABAADAAEAAgEGAAAAAAABAAAAAwAAAAIBAQGQAAACvAAAAAQEcwGQAAUAAAUzBM0AAACaBTMEzQAAAs0AagJQAAAAAAAAAAAAAAAAgAAAZwAAAGsAAAAAAAAAAFNUQwAAwAANIhUHbP1EAAAKKAMgIAABkwAAAAAD2gWLAAAAIAADAAEAAgCgAAAADgAAAFoADgAFAEQANgAoACAAGAACAAEAewB/AAAAAQAEAAECbwABAAQAAQKDAAIACgAGAAEE0gABAlIAAgAKAAYAAQTbAAECVwABAAQAAQJwAAEAAwAAADYAAAAsAAAAEAABAAwBFgEYARkBHAEdAR4BIgEjASQBKAEpASoAAQADAR8BIQErAAEABgEWARgBGQEcAR0BHgACAA0AAQArAAEALQBoAAEAagB6AAEAewB/AAIAgwCDAAEAjQCNAAEAlwCXAAEAoQChAAEBFgEWAAMBGAEZAAMBHAEfAAMBIQEkAAMBKAErAAMAAAAAAAwAlgADAAEECQAAAKQA/AADAAEECQABAA4A7gADAAEECQACAA4A4AADAAEECQADADIArgADAAEECQAEAB4AkAADAAEECQAFABoAdgADAAEECQAGAB4AWAADAAEECQAOADYAIgADAAEECQEAAAwAFgADAAEECQEBAA4A4AADAAEECQEFAAwACgADAAEECQEGAAoAAABSAG8AbQBhAG4ASQB0AGEAbABpAGMAVwBlAGkAZwBoAHQAaAB0AHQAcABzADoALwAvAG8AcABlAG4AZgBvAG4AdABsAGkAYwBlAG4AcwBlAC4AbwByAGcARwBlAGwAYQBzAGkAbwAtAFIAZQBnAHUAbABhAHIAVgBlAHIAcwBpAG8AbgAgADEALgAwADAAOABHAGUAbABhAHMAaQBvACAAUgBlAGcAdQBsAGEAcgAxAC4AMAAwADgAOwBTAFQAQwA7AEcAZQBsAGEAcwBpAG8ALQBSAGUAZwB1AGwAYQByAFIAZQBnAHUAbABhAHIARwBlAGwAYQBzAGkAbwBDAG8AcAB5AHIAaQBnAGgAdAAgADIAMAAyADIAIABUAGgAZQAgAEcAZQBsAGEAcwBpAG8AIABQAHIAbwBqAGUAYwB0ACAAQQB1AHQAaABvAHIAcwAgACgAaAB0AHQAcABzADoALwAvAGcAaQB0AGgAdQBiAC4AYwBvAG0ALwBTAG8AcgBrAGkAbgBUAHkAcABlAC8ARwBlAGwAYQBzAGkAbwApAAAAAAAwAIUAkQCdAKkAtQDBAM0A2QFuAc0CHAIoAm4CyAMyAz4DSgNWA2IDxQQlBJ4E2gTmBPIE/gUKBU0FWQXVBhkGhwbnBvMHLQc5B0UHUQddB64Hugg9CIwI5QkvCZ0KHwpwCsUK0QrdCukK9Qs+C5UMGwyADIwM2A0yDT0NSA1UDV8Naw13De4ORQ6JDpUO8A9dD6APqw+2D8IPzRAdEKUREhEeEVYRYRFtEXkRhRGREZ0R1xHiElQSjRMpE5ITnhPKE9YT4RPtE/gUAxQPFHQU1xU8FZYV5RZXFrUW+RdTF18Xahd2F4EXxBgRGJIY6BjzGP8ZTxnXGp8bWhvOHEMcnBzIHRcdSB2BHcEeKh5XHp0e4h8FH2MfqB/aIBEgUiC7IOchKSFsIY8h5iIqIlwilyLWI0EjbiOyI/YkGCRzJLok7CUmJWYl0iX/JkQmiSatJwgnTCd0J64n5ihOKHgotijxKRIpZimiKasptCm9KcYpzynYKeEp6inzKfwqCyocKi0qPipHKlAqWSpiKmIqYipiKmIqYipiKngqoSqtKrkqySr7KywrdivAK8kr4SxTLIosmSynLLAsuSzGLNMs4CztLRgtQi2FLcgt2i3sLfUuAi5WLmIujy68Lt8u/y8ULycvMy9RL/QwejC5MS8xtjJWMwIzKDNJM1UzYzN4M8Y0BzSTNRQ1hzYTNhs2MzZANmE2jjaiNrU2yjbmNyo3OjdPN1c3pTfBN9w4AjgYODk4XDh2OKI40TjeORc5LTlbOWc5jTmuOc856ToKOjY6ZTpyOno6kDq2Otc63zr5Ox87XztsO3U7oTvOO+wAAAACAAAAAwAAABQAAwABAAAAFAAEArgAAABKAEAABQAKAA0ALwA5AH4ArAD/AQIBMQFTArwCxgLaAtwDAQMEAwkDIwMpIAIgCSALIBQgGiAeICIgJiAzIDogRCB0IKwhIiGRIZMiEiIV//8AAAANACAAMAA6AKAArgECATEBUgK7AsYC2gLcAwADAwMIAyMDKSACIAkgCyATIBggHCAiICYgMiA5IEQgdCCsISIhkSGTIhIiFf//AL8AAABTAAAAAAAA/wH/IQAAAAD+af5W/lX+GP4ZAAD9/P344MfgweDA4MwAAAAA4LXgq+DK4Lfge+BS4Fff2N+D34Le9t7xAAEAAABIAAAAZADsAQQAAAAAAaIBpAAAAAAAAAAAAAABnAAAAAAAAAAAAAAAAAGSAZYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADHANIA8gDZAQIBEwD1APMA4gDjANgBBwDOAN4AzQDaAM8A0AENAQsBDADUAPQAAQAKAAsADQAPABQAFQAWABcAHAAeAB8AIAAhACMAKwAtAC4ALwAwADEANgA3ADgAOQA7AOYA2wDnAREA4QEtADwARABFAEcASQBOAE8AUABRAFgAWwBcAF0AXgBgAGgAagBrAGwAbgBvAHQAdQB2AHcAegDkAP4A5QEPAMgA0wEAAQQBAQEFAP8A9wEsAPgAgADuARAA+QEyAPsBDgDEAMUBLgESAPYA1gEzAMMAgQDvAMEAwADCANUABgACAAQACAAFAAcACQAMABMAEAARABIAGwAYABkAGgAOACIAJwAkACUAKQAmAQkAKAA1ADIAMwA0ADoALABtAEAAPQA+AEIAPwBBAEMARgBNAEoASwBMAFcAUwBUAFUASABfAGQAYQBiAGYAYwEKAGUAcwBwAHEAcgB4AGkAeQAqAGcBNQE0ARYBHgDsAO0A6ADqAOsA6QgAAQAFXv/lBV7/5QVe/+UFXv/lBV7/5QVe/+UFXv/lBV7/5QfE/58FOwA5BSMAQQUjAEEF/gBgBf4AXwU6AGAFOgBgBToAYAU6AGAFOgBgBMsAYAXNAFQGhQBgAx4AbAMeAGwDHgA5Ax4ASgMeAFkEJAAsBCQALAWOAGAE1ABgB2sAUQYjADUGIwA1BfQAXgX0AF4F9ABeBfQAXgX0AF4F9ABeBfQAXgf8AF4E4QBgBOoAYAX0AF4FnQBgBH0AbgTzACcGDQBKBg0ASgYNAEoGDQBKBg0ASgVV/9oHzv/8Ba8ADQTs/9QE7P/UBNAAQQQIAGEECABhBAgAYQQIAGEECABhBAgAYQQIAGEF5QBhBHv/5AOiAEUDogBFBJgAXARBAEYD3gBFA94ARQPeAEUD3gBFA94ARQKaADgEEwA5BKgAEAJYAC4CWAAuAlgALgJY/+ECWP/yAlgALgJY//ICVv/NAlb/zQJW/80ESQAGAkoAAgcMAC8EugAtBLoALQRQAE0EUABNBFAATQRQAE0EUABNBFAATQRQAE0GiABGBJIACwR5/+QEegBcA0cAPQN1AEQEYwASAsMAHgSaADEEmgAxBJoAMQSaADEEmgAxA/n/3gXm/84ECgAPA/D/7QPw/+0D8P/tA40AIgT2AD8HEgA/BxIAKgSpABgEuAAYBAAApgQAAHoEogCEBOkAkANwAJYEeABxBGoAWwSFADkEOgBABIcAYAQFAEMExQCLBIcAYAUaAI8DcACBBHgAfwRqAFMEhQApBDoAPASHAGAEBQBFBMUAiwSHAGAFGgB7BRoA2QUaAKAFGgBzBRoARgUaAIQFGgB9BRoAhAUaAJwFGgB9BRoAlwUaAPsFGgC5BRoAoQUaAFMFGgCNBRoAhQUaAI0FGgCkBRoAhQQAAHMEAACMBAAAkAQAAI8EAABKBAAAjwQAAIwEAAB1BAAAigQAAJAEAABzBAAAjAQAAJAEAACPBAAASgQAAI8EAACMBAAAdQQAAIoEAACQAKb+zwhmAFYIZgBWCGYAtAQAAIwEAACQBAAAjwQAAEoB7gAAAe4AAAQAAAABAAAAAAAAAAAAAAACKACIAigAeQKAAM8CgACjBnUA1wKmAMcCpgC+A9QARwPUAE4CPACSAyQAkQPHAEoFJQBj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LmRub20KdGhyZWUuZG5vbQlmb3VyLmRub20JZml2ZS5kbm9tCHNpeC5kbm9tCnNldmVuLmRub20KZWlnaHQuZG5vbQluaW5lLmRub20JemVyby5udW1yCG9uZS5udW1yCHR3by5udW1yCnRocmVlLm51bXIJZm91ci5udW1yCWZpdmUubnVtcghzaXgubnVtcgpzZXZlbi5udW1yCmVpZ2h0Lm51bXIJbmluZS5udW1yB3VuaTAwQjkHdW5pMDBCMgd1bmkwMEIzB3VuaTIwNzQHdW5pMDBBMAd1bmkyMDAyB3VuaTIwMDkHdW5pMjAwQgJDUhZwZXJpb2RjZW50ZXJlZC5sb2NsQ0FUG3BlcmlvZGNlbnRlcmVkLmxvY2xDQVQuY2FzZQZtaW51dGUGc2Vjb25kBEV1cm8HdW5pMjIxNQd1bmkwMEI1B2Fycm93dXAJYXJyb3dkb3duB3VuaTAzMDgHdW5pMDMwNwlncmF2ZWNvbWIJYWN1dGVjb21iB3VuaTAzMDIHdW5pMDMwQQl0aWxkZWNvbWIHdW5pMDMwNA1ob29rYWJvdmVjb21iDGRvdGJlbG93Y29tYgd1bmkwMzI3B3VuaTAzMjkMdW5pMDMwOC5jYXNlDmdyYXZlY29tYi5jYXNlDmFjdXRlY29tYi5jYXNlDHVuaTAzMDIuY2FzZQx1bmkwMzA2LmNhc2UMdW5pMDMwQS5jYXNlDnRpbGRlY29tYi5jYXNlDHVuaTAzMDQuY2FzZRJob29rYWJvdmVjb21iLmNhc2URZG90YmVsb3djb21iLmNhc2UHdW5pMDJCQwd1bmkwMkJCDG9TbGFzaF9wYXJ0LgAAAAABAAAACgA2AGAAAkRGTFQAHmxhdG4ADgAEAAAAAP//AAMAAAABAAIABAAAAAD//wACAAEAAgADa2VybgAkbWFyawAcbWttawAUAAAAAgADAAQAAAACAAEAAgAAAAEAAAAFCAoBqAEUANIADAAGABAAAQAKAAIAAQCgAKAAAQBuAAwADABcAFYAUABKAEQAPgA4ADIALAAmACAAGgABANIFswABAAAFJgABAAAFDgABAAAGHwAB/+cGHwABAAAFjQABAM0FswABAAAE8gABAAAFMwABAZ4FtQABAm4FnwABAAAFWQAMAAAHXgAAB1gAAAdSAAAHTAAAB0wAAAdGAAAHTAAA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) format('truetype');
}
@font-face {
font-family: 'Inter';
font-style: normal;
font-weight: 400;
src: url(data:font/ttf;base64,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BYUANAfiADQH4gA0B+IANAfiADQH4gA0BXUAOQV1ADkFbgA0BW4ANAVuADQFbgA0BW4ANAVuADQFbgA0BW4ANAUIAHoFCAB6BQgAegR+AFoEfgBaBH4AWgR+AFoEfgBaBH4AWgR+AFoEfgBaBH4AWgR+AFoHVwBaB1cAWgdXAFoE5gCeBOYAngTmAJ4EkgBoBJIAaASSAGgE5gBoBOYAaASqAGgEqgBoBKoAaASqAGgEqgBoBKoAaASqAGgEqgBoBKoAaAL2ABQE6ABoBOgAaAToAGgEuwCeBLsAngS7/68B8AB8AfAAngHw/7AB8P/WAfD/8QHwAJ4B8P+4AfD/5AHwAFIB8AB8AfAAfwHw/+YB8P/mBGQAngRkAJ4EZACeAfAAngLgAJ4B8ACeAfAAfQcCAJ4HAgCeBwIAngS6AJ4EugCeBLoAngS6AJ4EugCeBMwAaATMAGgEzABoBMwAUwTMAGgEzABoBMwAaATMAGgEzABoBMwAaATMAFMH/wBoBOYAngTmAJ4E5gBoAwMAngMDAJ4DAwB9BDkAbAQ5AGwEOQBsBO4AtAKeABQCngAUAp7/zQS7AJ4EuwCeBLsAngSwAJ4EuwCeBLsAngS7AJ4EuwCeBLsAngS7AJ4EfwA2BH8ANgR/ADYGjABGBowARgaMAEYGjABGBowARgReAEEEXgBBBH8ANgR/ADYEfwA2BH8ANgR/ADYEfwA2BH8ANgR/ADYEawB+BGsAfgRrAH4FFgCoBKkAaAUiAHQEkgBoBGYAHgTjAG4FVQA0BQwAegNBAGAE4QCaBPEAfQUrAHgEvwCABPYAegSHAGIE8wB6BPYAegUwAI4FMADhBTAAvQUwAJYFMAB5BTAAsgUwAJcFMAC2BTAAmAUwAJcCJgBsAiYAkAImAJACJgCQAiYAbAMgAP8DIABwAyAAUgMgAHADIAEiAyAAcAMgAP8DIABwAyAAUgMgAHADIAEiAyAAcAUwAU4FMAFOBTAAvwUwAL4FMADUBTAAtAUwAMMFMADDBTAAwwUwAL8FMACXBTABBgUwAL8FMAC+BTAA1AUwALQFMADDBTAAwwUwAMMFMAC/BTAAlwUwAMYCJgAAAiYAAAUnAGgCTQCgAk0AoAQXAFIEFwBmAusA2gLrAGAC6wDiAusAewNpAJADaQB7B7oAegLrANoC6wBgAusA4gLrAHsDaQCQA2kAewe6AHoFEQAiBcwAeALiAC4CqQEGAikAwALiAC4DrgCQBAAAAAgAAAAEgAEAA64AkAQAAAAIAAAABIABAAIWAKACFgCgAmYA0gO6ANIDhgCgA4YAoANeAHgB7gB4AcgAZgOKAGYCTgCAAk4AoAbqAKACTgCgAk4AoAJqAIACTgCgAxMAZAMTAFAEqQBkBKkAUAVLAK4FSwDtBUsA4gVLAMMFSwDSBUsA0gVLANIFSwDOBUsApgVLAK4FSwDtBUsA4gVLAMMFSwDSBUsA0gVLANIFSwDOBUsApgVLAOADpgAAA8UAUgQCAHIFKQDDBVQAZAdQAKgE4wBSA6UAggOhAEMD3ABOAZUAWAN7AGAE0gBuBIwAegJvAGMDiQBwA5EAZwOuAGUBif5wAxAATgIbAEsC8QBjAw0AZAMhAFsC+gB0AwwATgLGAEcDBQBOAwwATgMZAHkDDQB0AxoAhgHrAIUB6wA8AdgAgAHYAGYDEABOAhsASwLxAGMDDQBkAyEAWwL6AHQDDABOAsYARwMFAE4DDABOAxkAeQMNAHQDGgCGAesAhQHrADwB2ACAAdgAZgbHAEsGawBLBw4AZAfbAOYClQCoApUAlgS6ARQDTgBmBAoA4gPSANQCYgAqAiUAmwAAAKgAAACWAAAA1AAAAOIB7wB6AkAAAAJAAAAEAAAAAXQAAAAAAAAHogDKCroAyhV0AMoKugDKB6IBAAq6AQAVdAEAB6IBAAq6AQAKugDKDgAAygq6AMoOAADKBqwAygasAMoHogDKCroAyhV0AMoKugDKB6IBAAq6AQAVdAEAB6IBAAq6AQAKugDKDgAAygq6AMoOAADKBeEAFASAALQAAAAAAAABFAAAAHoAAABmAAAAKgAAAGQAAACbAAAA1ASwARQEugEUBLABFAPSAKQEAADiAAAAKgQAALwEAADiAiUAfgScAAYEyQBSAWsAWgAAANQDaQAyAAIAAAAAAAD+pACMAAAAAAAAAAAAAAAAAAAAAAAAAAACBwAAAAEAJABiAK4ArQDJAMcAYwECAQMBBAEFAJABBgEHACUBCAAmAGQA/QAnAQkAKADLAGUAyADKAQoBCwEMAQ0BDgEPACkAKgEQAREAKwESARMALADOARQAzwDMAM0BFQEWARcBGAAtAC4BGQEaAC8BGwEcADABHQEeADEAZgEfASABIQAyAGcArwCRANMA0ADRASIBIwEkASUBJgEnASgBKQEqASsAsAAzASwANAA1AS0BLgA2AS8BMAA3ATEAOADWANQA1QBoATIBMwE0ATUBNgE3ATgBOQE6ADkBOwE8ADoBPQE+AT8BQAA7AUEAPADrALsBQgFDAUQBRQFGAD0BRwFIAEQAaQBrAGwBSQBqAUoBSwBuAG0AoAFMAU0ARQFOAO4ARgBvAP4ARwFPAEgAcwBxAHAAcgFQAVEBUgFTAEkASgFUAVUASwFWAVcATADXAHcBWAB1AHQAdgFZAVoBWwFcAV0ATQBOAV4BXwBPAWABYQFiAFABYwFkAFEAeAFlAWYBZwBSAHwAfQChAHoAeQB7AWgBaQFqAWsAsQBTAWwAVABVAW0BbgBWAW8BcACJAFcBcQFyAFgAgQFzAXQAfwB+AIABdQF2AXcAWQF4AXkAWgF6AXsBfAF9AFsBfgBcALoA7AF/AYABgQGCAYMAXQGEAYUA7QDqAAcAhACWAIUBhgATABQAFQAWABcAGAAZABoAGwAcAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AAkABACjACIAogALAAwAPgBAAF4AYAAjAboBuwG8Ab0BvgG/AcAABgC9ABIAXwDoAD8AEACyALMAhwHBAcIBwwHEALYAtwAKAAUAtAC1AMUAxAHFAcYADwARAKsAHQHHAB4AwwC+AL8AqQCqAB8AIQAgAA4A7wDwALgAkwBhAcgByQHKAcsBzAHNAc4BzwHQAKQAQgBBAA0B0QCKAIsAjACDAJ0AngHSAdMAiACGAdQB1QHWAdcAvAHYAdkB2gHbAdwB3QHeAd8B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAfQB9QH2AfcB+AH5APQA9QD2AAgAjQBDAI4A2ADZANoA3QDeAfoB+wH8Af0B/gADAf8CAAIBAgICAwIEAgUCBgIHAggCCQIKAgsCDAINAg4CDwIQAhECEgITAhQCFQIWAhcCGAIZAhoCGwIcAh0CHgDpAh8CIAIhAiICIwIkAiUCJgInAigCKQIqAisCLAItAi4CLwIwAjECMgIzAjQCNQdBbWFjcm9uB3VuaTAxREUHdW5pMUVBMAd1bmkxRUEyB3VuaTAxRTIHQUVhY3V0ZQd1bmkxRTA0B3VuaTFFMEMHRW1hY3Jvbgd1bmkxRTE0B3VuaTFFMTYHdW5pMUVCOAd1bmkxRUJBB3VuaTFFQkMHdW5pMDFGNAd1bmkxRTIwB3VuaTFFMjQHdW5pMUUyNgd1bmkxRTJFBkl0aWxkZQdJbWFjcm9uB3VuaTFFQzgHdW5pMUVDQQd1bmkxRTMwB3VuaTFFMzIGTGFjdXRlB3VuaTFFMzYHdW5pMUUzRQd1bmkxRTQyBk5hY3V0ZQd1bmkwMUY4B3VuaTFFNDYHT21hY3Jvbgd1bmkwMjJBB3VuaTAyMkMHdW5pMUU0Qwd1bmkxRTRFB3VuaTFFNTAHdW5pMUU1Mgd1bmkxRUNDB3VuaTFFQ0ULT3NsYXNoYWN1dGUHdW5pMUU1NAZSYWN1dGUHdW5pMUU1QQZTYWN1dGUHdW5pMUU2Mgd1bmkxRTZDBlV0aWxkZQdVbWFjcm9uB3VuaTAxRDUHdW5pMDFENwd1bmkwMURCB3VuaTFFNzgHdW5pMUU3QQd1bmkxRUU0B3VuaTFFRTYHdW5pMUU3Qwd1bmkxRTdFBldncmF2ZQZXYWN1dGUJV2RpZXJlc2lzB3VuaTFFODgHdW5pMUU4Qwd1bmkwMjMyBllncmF2ZQd1bmkxRUY0B3VuaTFFRjYHdW5pMUVGOAZaYWN1dGUHdW5pMUU5Mgd1bmkxRUExB3VuaTFFQTMHYW1hY3Jvbgd1bmkwMUUzB2FlYWN1dGUHdW5pMUUwNQd1bmkxRTBEB2VtYWNyb24HdW5pMUVCOQd1bmkxRUJCB3VuaTFFQkQHdW5pMDFGNQd1bmkxRTIxB3VuaTFFMjUHdW5pMUUyNwZpdGlsZGUHaW1hY3Jvbgd1bmkxRUM5B3VuaTFFQ0IMdW5pMUVDQi5jY21wB3VuaTAyMzcHdW5pMUUzMQd1bmkxRTMzBGxkb3QGbGFjdXRlB3VuaTFFMzcHdW5pMUUzRgd1bmkxRTQzBm5hY3V0ZQd1bmkwMUY5B3VuaTFFNDcHb21hY3Jvbgd1bmkxRUNEB3VuaTFFQ0YLb3NsYXNoYWN1dGUHdW5pMUU1NQZyYWN1dGUHdW5pMUU1QgZzYWN1dGUHdW5pMUU2Mwd1bmkxRTZEB3VuaTFFOTcGdXRpbGRlB3VuaTAwQjUHdW1hY3Jvbgd1bmkxRUU1B3VuaTFFRTcHdW5pMUU3RAd1bmkxRTdGCXdkaWVyZXNpcwZ3Z3JhdmUGd2FjdXRlB3VuaTFFODkHdW5pMUU4RAd1bmkwMjMzBnlncmF2ZQd1bmkxRUY1B3VuaTFFRjcHdW5pMUVGOQZ6YWN1dGUHdW5pMUU5MwRFdXJvB3plcm8udGYGb25lLnRmBnR3by50Zgh0aHJlZS50Zgdmb3VyLnRmB2ZpdmUudGYGc2l4LnRmCHNldmVuLnRmCGVpZ2h0LnRmB25pbmUudGYIY29tbWEudGYJcGVyaW9kLnRmCGNvbG9uLnRmDWNvbG9uLmNhc2UudGYMc2VtaWNvbG9uLnRmDHBhcmVubGVmdC50Zg1wYXJlbnJpZ2h0LnRmDGJyYWNlbGVmdC50Zg1icmFjZXJpZ2h0LnRmDmJyYWNrZXRsZWZ0LnRmD2JyYWNrZXRyaWdodC50ZhFwYXJlbmxlZnQuY2FzZS50ZhJwYXJlbnJpZ2h0LmNhc2UudGYRYnJhY2VsZWZ0LmNhc2UudGYSYnJhY2VyaWdodC5jYXNlLnRmE2JyYWNrZXRsZWZ0LmNhc2UudGYUYnJhY2tldHJpZ2h0LmNhc2UudGYJaHlwaGVuLnRmDmh5cGhlbi5jYXNlLnRmB2xlc3MudGYKZ3JlYXRlci50ZghlcXVhbC50ZgdwbHVzLnRmCG1pbnVzLnRmC211bHRpcGx5LnRmCWRpdmlkZS50ZgxwbHVzbWludXMudGYNYXNjaWl0aWxkZS50Zgthc3Rlcmlzay50ZgxsZXNzLmNhc2UudGYPZ3JlYXRlci5jYXNlLnRmDWVxdWFsLmNhc2UudGYMcGx1cy5jYXNlLnRmDW1pbnVzLmNhc2UudGYQbXVsdGlwbHkuY2FzZS50Zg5kaXZpZGUuY2FzZS50ZhFwbHVzbWludXMuY2FzZS50ZhJhc2NpaXRpbGRlLmNhc2UudGYQYXN0ZXJpc2suY2FzZS50ZghzcGFjZS50Zgp1bmkwMEEwLnRmDnBhcmVubGVmdC5jYXNlD3BhcmVucmlnaHQuY2FzZRBicmFja2V0bGVmdC5jYXNlEWJyYWNrZXRyaWdodC5jYXNlDmJyYWNlbGVmdC5jYXNlD2JyYWNlcmlnaHQuY2FzZQdhdC5jYXNlC2h5cGhlbi5jYXNlC2VuZGFzaC5jYXNlC2VtZGFzaC5jYXNlC2J1bGxldC5jYXNlBXByaW1lC2RvdWJsZXByaW1lCmNvbG9uLmNhc2UJbGVzcy5jYXNlDGdyZWF0ZXIuY2FzZQplcXVhbC5jYXNlCXBsdXMuY2FzZQptaW51cy5jYXNlDW11bHRpcGx5LmNhc2ULZGl2aWRlLmNhc2UOcGx1c21pbnVzLmNhc2UPYXNjaWl0aWxkZS5jYXNlDWFzdGVyaXNrLmNhc2UGaS5udW1yBm4ubnVtcghvbmUuc3Vwcwh0d28uc3Vwcwp0aHJlZS5zdXBzCWZvdXIuc3Vwcwl6ZXJvLmRub20Ib25lLmRub20IdHdvLmRub20KdGhyZWUuZG5vbQlmb3VyLmRub20JZml2ZS5kbm9tCHNpeC5kbm9tCnNldmVuLmRub20KZWlnaHQuZG5vbQluaW5lLmRub20JcGx1cy5kbm9tCm1pbnVzLmRub20KZXF1YWwuZG5vbQ5wYXJlbmxlZnQuZG5vbQ9wYXJlbnJpZ2h0LmRub20LcGVyaW9kLmRub20KY29tbWEuZG5vbQl6ZXJvLm51bXIIb25lLm51bXIIdHdvLm51bXIKdGhyZWUubnVtcglmb3VyLm51bXIJZml2ZS5udW1yCHNpeC5udW1yCnNldmVuLm51bXIKZWlnaHQubnVtcgluaW5lLm51bXIJcGx1cy5udW1yCm1pbnVzLm51bXIKZXF1YWwubnVtcg5wYXJlbmxlZnQubnVtcg9wYXJlbnJpZ2h0Lm51bXILcGVyaW9kLm51bXIKY29tbWEubnVtcglhY3V0ZWNvbWIJZ3JhdmVjb21iB3VuaTAzMDQJdGlsZGVjb21iCGRvdGJlbG93B3VuaTAwQTAHdW5pMjAwMgd1bmkyMDA5B3VuaTIwMEIJYXJyb3dsZWZ0B3VuaTI3RjUObGVmdExvbmdBcnJvdzIHdW5pMjdGOAphcnJvd3JpZ2h0B3VuaTI3RjYPcmlnaHRMb25nQXJyb3cyDWFycm93ZGJscmlnaHQHdW5pMjdGOQlhcnJvd2JvdGgHdW5pMjdGNwxhcnJvd2RibGJvdGgHdW5pMjdGQQdhcnJvd3VwCWFycm93ZG93bg5hcnJvd2xlZnQuY2FzZQx1bmkyN0Y1LmNhc2UTbGVmdExvbmdBcnJvdzIuY2FzZQx1bmkyN0Y4LmNhc2UPYXJyb3dyaWdodC5jYXNlDHVuaTI3RjYuY2FzZRRyaWdodExvbmdBcnJvdzIuY2FzZRJhcnJvd2RibHJpZ2h0LmNhc2UMdW5pMjdGOS5jYXNlDmFycm93Ym90aC5jYXNlDHVuaTI3RjcuY2FzZRFhcnJvd2RibGJvdGguY2FzZQx1bmkyN0ZBLmNhc2UETGRvdAd1bmkyMDBEB3VuaTAzMDgHdW5pMDMwNwd1bmkwMzAyB3VuaTAzMEENaG9va2Fib3ZlY29tYgd1bmkwMzI3B3VuaTFEQzQUZGllcmVzaXNhY3V0ZWNvbWIubGMVZGllcmVzaXNtYWNyb25jb21iLmxjFGRpZXJlc2lzZ3JhdmVjb21iLmxjFW1hY3JvbmRpZXJlc2lzY29tYi5sYw10aWxkZWFjdXRlLmxjCnVuaTAzMEEudWMUdGlsZGVkaWVyZXNpc2NvbWIubGMSdGlsZGVtYWNyb25jb21iLmxjB3VuaTAyQkIMX3BhcnQuT3NsYXNoDF9wYXJ0Lm9zbGFzaAx1bmkyMDcxLmNjbXAKdW5pMURDNi5sYxFjcm9zc2Jhcl9zaG9ydC51YwABAAAACgBQANIAAkRGTFQALmxhdG4ADgAkAAFDQVQgAAoAAP//AAgAAAABAAIAAwAEAAUABgAHAAQAAAAA//8ABwAAAAEAAgADAAUABgAHAAhjYWx0AHZjY21wAG5kbm9tAGhmcmFjAEpsb2NsAERudW1yAD5wbnVtADh0bnVtADIAAAABACoAAAABACkAAAABAAYAAAABAAMAAAANAAgACgAMAA4AEAASABQAFgAYABoAHAAeACAAAAABAAcAAAACAAAAAgAAAAQAIgAjACYAJwArKawpliLkIqIigiJiIgYhuh+SH4QfZB80Hw4fNB7wHzQe0B80Hq4fNB6KHzQeZB80HjwfNB4SHzQd5h80HcIhuh2gHZIMUAvaC8ALngoEAg4BigEMAFgAAQAAAAEACAACAGwAMwEMAQ0BDgEPARABEQESARMBFAEVARsBHAEfASABHQEeASEBIgElASYBIwEkAScBKAEWARcBGAEZARoBKQEqASsBLAEtAS4BLwEwATEBMwE0ATUBNgE3ATgBOQE6ATsBMgE8AT0BPgACAAoBAgELAAABRAFJ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AAMBXAFeAeMAAwFcAV0B4wADAVwBXAHjAAMBXAFaAeMAAwFcAVkB4wADAVwBWAHjAAMBWgFeAeMAAwFaAV0B4wADAVoBXAHjAAMBWgFaAeMAAwFaAVkB4wADAVoBWAHjAAMBWQFeAeMAAwFZAV0B4wADAVkBXAHjAAMBWQFaAeMAAwFZAVkB4wADAVkBWAHjAAMBWAFeAeMAAwFYAV0B4wADAVgBXAHjAAMBWAFaAeMAAwFYAVkB4wADAVgBWAHkAAQBXgFeAV4B5AAEAV4BXgFdAeQABAFeAV4BXAHkAAQBXgFeAVoB5AAEAV4BXgFZAeQABAFeAV4BWAHkAAQBXgFdAV4B5AAEAV4BXQFdAeQABAFeAV0BXAHkAAQBXgFdAVoB5AAEAV4BXQFZAeQABAFeAV0BWAHkAAQBXgFcAV4B5AAEAV4BXAFdAeQABAFeAVwBXAHkAAQBXgFcAVoB5AAEAV4BXAFZAeQABAFeAVwBWAHkAAQBXgFaAV4B5AAEAV4BWgFdAeQABAFeAVoBXAHkAAQBXgFaAVoB5AAEAV4BWgFZAeQABAFeAVoBWAHkAAQBXgFZAV4B5AAEAV4BWQFdAeQABAFeAVkBXAHkAAQBXgFZAVoB5AAEAV4BWQFZAeQABAFeAVkBWAHkAAQBXgFYAV4B5AAEAV4BWAFdAeQABAFeAVgBXAHkAAQBXgFYAVoB5AAEAV4BWAFZAeQABAFeAVgBWAHkAAQBXQFeAV4B5AAEAV0BXgFdAeQABAFdAV4BXAHkAAQBXQFeAVoB5AAEAV0BXgFZAeQABAFdAV4BWAHkAAQBXQFdAV4B5AAEAV0BXQFdAeQABAFdAV0BXAHkAAQBXQFdAVoB5AAEAV0BXQFZAeQABAFdAV0BWAHkAAQBXQFcAV4B5AAEAV0BXAFdAeQABAFdAVwBXAHkAAQBXQFcAVoB5AAEAV0BXAFZAeQABAFdAVwBWAHkAAQBXQFaAV4B5AAEAV0BWgFdAeQABAFdAVoBXAHkAAQBXQFaAVoB5AAEAV0BWgFZAeQABAFdAVoBWAHkAAQBXQFZAV4B5AAEAV0BWQFdAeQABAFdAVkBXAHkAAQBXQFZAVoB5AAEAV0BWQFZAeQABAFdAVkBWAHkAAQBXQFYAV4B5AAEAV0BWAFdAeQABAFdAVgBXAHkAAQBXQFYAVoB5AAEAV0BWAFZAeQABAFdAVgBWAHkAAQBXAFeAV4B5AAEAVwBXgFdAeQABAFcAV4BXAHkAAQBXAFeAVoB5AAEAVwBXgFZAeQABAFcAV4BWAHkAAQBXAFdAV4B5AAEAVwBXQFdAeQABAFcAV0BXAHkAAQBXAFdAVoB5AAEAVwBXQFZAeQABAFcAV0BWAHkAAQBXAFcAV4B5AAEAVwBXAFdAeQABAFcAVwBXAHkAAQBXAFcAVoB5AAEAVwBXAFZAeQABAFcAVwBWAHkAAQBXAFaAV4B5AAEAVwBWgFdAeQABAFcAVoBXAHkAAQBXAFaAVoB5AAEAVwBWgFZAeQABAFcAVoBWAHkAAQBXAFZAV4B5AAEAVwBWQFdAeQABAFcAVkBXAHkAAQBXAFZAVoB5AAEAVwBWQFZAeQABAFcAVkBWAHkAAQBXAFYAV4B5AAEAVwBWAFdAeQABAFcAVgBXAHkAAQBXAFYAVoB5AAEAVwBWAFZAeQABAFcAVgBWAHkAAQBWgFeAV4B5AAEAVoBXgFdAeQABAFaAV4BXAHkAAQBWgFeAVoB5AAEAVoBXgFZAeQABAFaAV4BWAHkAAQBWgFdAV4B5AAEAVoBXQFdAeQABAFaAV0BXAHkAAQBWgFdAVoB5AAEAVoBXQFZAeQABAFaAV0BWAHkAAQBWgFcAV4B5AAEAVoBXAFdAeQABAFaAVwBXAHkAAQBWgFcAVoB5AAEAVoBXAFZAeQABAFaAVwBWAHkAAQBWgFaAV4B5AAEAVoBWgFdAeQABAFaAVoBXAHkAAQBWgFaAVoB5AAEAVoBWgFZAeQABAFaAVoBWAHkAAQBWgFZAV4B5AAEAVoBWQFdAeQABAFaAVkBXAHkAAQBWgFZAVoB5AAEAVoBWQFZAeQABAFaAVkBWAHkAAQBWgFYAV4B5AAEAVoBWAFdAeQABAFaAVgBXAHkAAQBWgFYAVoB5AAEAVoBWAFZAeQABAFaAVgBWAHkAAQBWQFeAV4B5AAEAVkBXgFdAeQABAFZAV4BXAHkAAQBWQFeAVoB5AAEAVkBXgFZAeQABAFZAV4BWAHkAAQBWQFdAV4B5AAEAVkBXQFdAeQABAFZAV0BXAHkAAQBWQFdAVoB5AAEAVkBXQFZAeQABAFZAV0BWAHkAAQBWQFcAV4B5AAEAVkBXAFdAeQABAFZAVwBXAHkAAQBWQFcAVoB5AAEAVkBXAFZAeQABAFZAVwBWAHkAAQBWQFaAV4B5AAEAVkBWgFdAeQABAFZAVoBXAHkAAQBWQFaAVoB5AAEAVkBWgFZAeQABAFZAVoBWAHkAAQBWQFZAV4B5AAEAVkBWQFdAeQABAFZAVkBXAHkAAQBWQFZAVoB5AAEAVkBWQFZAeQABAFZAVkBWAHkAAQBWQFYAV4B5AAEAVkBWAFdAeQABAFZAVgBXAHkAAQBWQFYAVoB5AAEAVkBWAFZAeQABAFZAVgBWAHkAAQBWAFeAV4B5AAEAVgBXgFdAeQABAFYAV4BXAHkAAQBWAFeAVoB5AAEAVgBXgFZAeQABAFYAV4BWAHkAAQBWAFdAV4B5AAEAVgBXQFdAeQABAFYAV0BXAHkAAQBWAFdAVoB5AAEAVgBXQFZAeQABAFYAV0BWAHkAAQBWAFcAV4B5AAEAVgBXAFdAeQABAFYAVwBXAHkAAQBWAFcAVoB5AAEAVgBXAFZAeQABAFYAVwBWAHkAAQBWAFaAV4B5AAEAVgBWgFdAeQABAFYAVoBXAHkAAQBWAFaAVoB5AAEAVgBWgFZAeQABAFYAVoBWAHkAAQBWAFZAV4B5AAEAVgBWQFdAeQABAFYAVkBXAHkAAQBWAFZAVoB5AAEAVgBWQFZAeQABAFYAVkBWAHkAAQBWAFYAV4B5AAEAVgBWAFdAeQABAFYAVgBXAHkAAQBWAFYAVoB5AAEAVgBWAFZAeQABAFYAVgBWAAmAaYBnAGSAYgBfgF0AWoBYAFWAUwBQgE4AS4BJAEaARABBgD8APIA6ADeANQAygDAALYArACiAJoAkgCKAIIAegByAGoAYgBaAFQATgHUAAIBWgHUAAIBWQHUAAMBWgFaAdQAAwFaAVkB1AADAVoBWAHUAAMBWQFaAdQAAwFZAVkB1AADAVkBWAHUAAMBWAFaAdQAAwFYAVkB1AADAVgBWAHVAAQBWgFaAVoB1QAEAVoBWgFZAdUABAFaAVoBWAHVAAQBWgFZAVoB1QAEAVoBWQFZAdUABAFaAVkBWAHVAAQBWgFYAVoB1QAEAVoBWAFZAdUABAFaAVgBWAHVAAQBWQFaAVoB1QAEAVkBWgFZAdUABAFZAVoBWAHVAAQBWQFZAVoB1QAEAVkBWQFZAdUABAFZAVkBWAHVAAQBWQFYAVoB1QAEAVkBWAFZAdUABAFZAVgBWAHVAAQBWAFa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AAIAAQAAAAAAAAABAAcAAQABAAEAAQABAAEAAgAAAAcAAQABAAEAAQABAAEAAgABAAAAAAAAAAEACAABAAEAAQABAAEAAQABAAIAAAAIAAEAAQABAAEAAQABAAEAAgABAAAAAAAAAAEACQABAAEAAQABAAEAAQABAAEAAgAAAAkAAQABAAEAAQABAAEAAQABAAIAAQAAAAAAAAABAAoAAQABAAEAAQABAAEAAQABAAEAAgAAAAoAAQABAAEAAQABAAEAAQABAAEAAgABAAAAAAAAAAEACwABAAEAAQABAAEAAQABAAEAAQABAAIAAAALAAEAAQABAAEAAQABAAEAAQABAAEAAgABAAAAAAABAVQAAQABAAIABQECAQsAAQFEAUUAAQFUAVQAAgFqAWsAAQF3AXkAAQABAAEBVAABAAAAAQAIAAIAKAARAZsBnAGdAZ4BnwGgAaEBogGjAaQBqAGpAasBqgGnAaUBpgACAAQBAgELAAABRAFFAAoBagFrAAwBdwF5AA4AAQAAAAEACAACACwAEwGSAZMBrAGtAa4BrwGwAbEBsgGzAbQBtQG5AboBvAG7AbgBtgG3AAIABgCnAKcAAAC+AL4AAQECAQsAAgFEAUUADAFqAWsADgF3AXkAEAAEAAAAAQAIAAEAEgABAAgAAQAEAfAAAgFwAAEAAQA3AAQAAAABAAgAAQASAAEACAABAAQAuAACAXAAAQABALcABgAAAAEACAABAAoAAgAmABIAAQACADcAtwABAAQAAAACAXAAAQC3AAEAAAAEAAEABAAAAAIBcAABADcAAQAAAAUABAAAAAEACAABBkAAMwX8BeoF4AXWBcwFfgVsBVoFFgUEBPIE4AS+BEgEPgQ0BCIEEAQGA5oDiANmA1wDIgMQAtYCxAK6ArACpgJsAloCSAI+AgwB+gHoAdYBtAF6AXABZgFUAUIBMAD2AOQAwgC4AH4AbAACAAwABgD6AAIBzQD5AAIByQAHADQALgAoACIAHAAWABAA8wACAcsA9wACAcwA9gACAfYA9QACAc0A9AACAcoA8QACAfIA8gACAckAAQAEAO8AAgHyAAQAHAAWABAACgDtAAIBzQDqAAIB8gDsAAIByQDrAAIBygACAAwABgDoAAIBzQDnAAIBzAAHADQALgAoACIAHAAWABAA5QACAfYA5AACAc0A4wACAcsA3gACAcwA3QACAfIA4QACAckA4AACAcoAAgAMAAYA2wACAfIA2gACAc0AAgAMAAYA1wACAc0A1gACAckAAgAMAAYA1AACAc0A0wACAckAAQAEANAAAgHJAAEABADNAAIByQAHADQALgAoACIAHAAWABAAzAACAfYAywACAc0AygACAcsAxAACAfIAxQACAcwAyAACAckAxwACAcoABAAcABYAEAAKAMIAAgHNAMEAAgHKAMAAAgHJAL8AAgHMAAIADAAGAL0AAgHNALwAAgHJAAIADAAGALoAAgHNALkAAgHJAAIADAAGALYAAgHNALUAAgHJAAYALAAmACAAGgAUAA4ArwACAfYArgACAcsAqgACAcwAqQACAfIArAACAckAqwACAcoAAQAEALAAAgHNAAIADAAGAKYAAgHyAKUAAgHNAAIADAAGAKMAAgHLAKIAAgHJAAcANAAuACgAIgAcABYAEACfAAIBzACeAAIB9gCdAAIBzQCcAAIBywCYAAIB8gCaAAIByQCZAAIBygABAAQAlgACAc0AAQAEAJQAAgHJAAEABACQAAIBzQACAAwABgCNAAIBywCOAAIByQAHADQALgAoACIAHAAWABAAiAACAfYAhgACAc0AiQACAcsAhQACAfIAiwACAcwAgwACAckAhwACAcoAAgAMAAYAgQACAc0AgAACAckABwA0AC4AKAAiABwAFgAQAHoAAgHLAH4AAgHMAH0AAgH2AHwAAgHNAHsAAgHKAHkAAgHyAHgAAgHJAAEABAB2AAIB8gAEABwAFgAQAAoAdAACAc0AcwACAfIAcgACAckAcQACAcoAAgAMAAYAbwACAc0AbgACAcwADABkAFwAVABMAEQAPgA4ADIALAAmACAAGgBsAAIB9gBrAAIBzQBlAAIBywBkAAIBzABjAAIB8gBhAAIByQBgAAIBygBqAAMBywHyAGkAAwHMAckAaAADAfIBygBnAAMB8gHJAGYAAwHyAcsAAQAEAF4AAgHNAAIADAAGAFwAAgHNAFsAAgHJAAIADAAGAFkAAgHNAFgAAgHJAAEABABVAAIByQABAAQAUgACAckADQBuAGYAXgBWAE4ARgBAADoANAAuACgAIgAcAFEAAgH2AFAAAgHNAEkAAgHLAEMAAgHyAEQAAgHMAEcAAgHJAEYAAgHKAE8AAwHLAckATgADAcsBygBNAAMBzAHyAEwAAwHMAckASwADAcwBywBKAAMB8gHLAAQAHAAWABAACgBBAAIBzQBAAAIBygA/AAIByQA+AAIBzAACAAwABgA8AAIBzQA7AAIByQACAAwABgA5AAIBzQA4AAIByQACAAwABgA2AAIBzQA1AAIByQAIADwANgAwACoAJAAeABgAEgAyAAIBzQAxAAIB9gAwAAIBywAvAAIBzAAqAAIB8gAtAAIByQAsAAIBygArAAMB8gHJAAIADAAGACgAAgHyACcAAgHNAAIADAAGACUAAgHLACQAAgHJAAkARgA+ADgAMgAsACYAIAAaABQAIQACAcwAIAACAfYAHwACAc0AHAACAcsAGwACAfIAGQACAckAGAACAcoAHgADAcsByQAdAAMBywHKAAEABAAWAAIBzQABAAQAFAACAckAAQAEABEAAgHNAAIADAAGAA4AAgHLAA8AAgHJAAgAPAA2ADAAKgAkAB4AGAASAAwAAgH2AAsAAgHNAAkAAgHLAAMAAgHyAAQAAgHMAAYAAgHJAAUAAgHKAAoAAwHyAcsAAQAzAAIADQAQABIAFQAXACMAJgApADQANwA6AD0AQgBFAFQAVwBaAF0AXwBtAHAAdQB3AH8AggCMAI8AkgCVAJcAoQCkAKcAqAC0ALcAuwC+AMMAxgDPANIA1QDZANwA5gDpAO4A8AD4AAEAAAABAAgAAgB0AAQAqACxALICBAAGAAAAAQAIAAIAXgBaAD4AKAAFAAAAFgAWABYAFgABAAQAAAABAAEAAQABAAAAAQACAAMByQHMAAEB8gHyAAEB9gH2AAEAAgAEAKcApwABALAAsAADALMAswAEAZIBkgACAAIAAAABAAQApwCwALMBkgABAAAACgBQAJIABERGTFQANmN5cmwAKmdyZWsAKmxhdG4AGgAEAAAAAP//AAMAAAACAAMABAAAAAD//wABAAAABAAAAAD//wADAAEAAgADAARrZXJuADhrZXJuAChtYXJrACBta21rABoAAAABAAUAAAACAAMABAAAAAYAAQACAAAAAQACAAAAAAADAAEAAgAAAAYhtApKCiIGqgBWAA4ABgAQAAEACgABAAEGggAwAAEGRAAMAAUAHgAYABIADAMcAAECBQXxAAEB6QXTAAEBngYWAAEA9wYWAAEABQHJAcoBywHMAfIABAAAAAEACAABBjwFggABBf4ADAEKBXAFagVkBV4FXgVeBXAFWAVwBXAFcAVSBUwFRgVABUAFOgU6BTQFLgUuBSgFIgUiBSIFHAUWBSgFKAUoBSgFEAUKBQQE/gT4BPIE8gTsBOYE4ATmBNoE2gTaBNQEzgTmBOYEyATCBLwEwgTmBNoE5gS2BLAEtgSqBKQEngSeBKoEmASSBIwEmASGBIYEhgSABJgEmASYBJgEmASYBJgEmASGBHoEdARuBJgEaARiBGgEXARWBFwEUARQBEoERAREBEQEPgQ4BDIESgRKBEoESgRKBEoESgVwBWQFcAQsBCYEJgQgBCwEGgQUBA4ECAQCA/wECAQOBA4D9gPwA+oD8APkA94D3gPYA+QD3gPkA9ID5APMA8YDwAO6A7QDtAOuA64DqAOiA6IDnAOWA5ADkAOQA4oDnAOcA4QDfgYSA3gDcgNsA2wDZgNgA1oDVANOA0gDSANIA0IDWgNgA1oDPANsAzYDbANsA2wDNgNsAzADKgMwBhIDJAN4A3gGEgOuAx4DGAOuA6gDqAOoAxIDrgOuA6gDDAMGAwAC+gL0AvoC7gLoAu4C4gLiAtwGEgLWAyQDeAN4A3gDcgYSBhIC0ALKAtACxAK+ArgCuALEArICrAKmAqACmgKUApoCpgKmAo4CiAKCAogEXAJ8AnYCcAJqAmQCXgJeAlgCUgJMAkYCQAI6AjQCLgIoAiICHAIiAnYCFgABAsUDywABBVADLAABAZIF0gABAXoF0gABAYgF0gABAZIDLAABAXoDLAABAYgDLAABAc0GrgABAcUGrgABAe0F4AABAcUF4AABApMF0gABApgF0gABAnoF0gABAnAF0gABAoYF0gABAmUFHAABAisGFgABAisEXgABAkAF8QABAkAF0wABAkAGFgABAkAGAgABAkAEXgABAi8GAgABAi8EXgABA0YGFgABA0YGAgABA0YEXgABAj8F8QABAj8EXgABAl0GAgABARYHDAABARYFaAABAikGFgABAikEXgABAasGFgABAasEXgABAm8EXgABApgGFgABApgEXgABAmUF0wABAmUF8QABAmUGAgABAl0F8QABA4AGFgABA4AEXgABAPgHigABAPgEXgABAPkF0wABAPkGFgABAPkF8QABAPkGAgABAPkEXgABAPkGAwABAPgHdgABAPgF0gABAl0F0wABAl0GFgABAZgGEAABAlsF8QABAlsF0wABAlsGFgABAlsGAgABAlsEXgABAkYFGAABAmUGFgABAmUEXgABAqAFGAABA6MGFgABA6MF0wABA6MEXgABAi4F8QABAi4F0wABAi4GAgABAi4GFgABAi4EXgABAoQHigABAoQF0gABArcHZQABArcHRwABArcHdgABArcHigABArcF0gABAroHdgABAroF0gABA/EHdgABA/EHigABA/EF0gABAvsHRwABAvsHZQABAvsHdgABAvsHigABAvsF0gABApYF0gABApAHigABApAF0gABAosHigABAosF0gABAowHigABAowF0gABBboF0gABAxAHRwABAxAHigABAxAHZQABAxAHdgABAxAF0gABAwQHigABAwQHZQABAwQF0gABA5kHigABA5kF0gABAsAHigABAsAF0gABA34F0gABARMHRwABARMHZQABARMHigABARMHdgABARMF0gABAvgHdgABAvgF0gABAwkHRwABAwkHigABAwkF0gABAncF0gABAn8HZQABAn8HRwABAn8HdgABAn8HigABAn8F0gABAmsF0gABAw8HigABAw8F0gABAoMF0gABBS4HigABBS4HRwABBS4F0gABAsIHRwABAsIHigABAsIHZQABAsIHdgABAsIF0gACABQAAgCQAAAAkgCyAI8AtADNALAAzwDXAMoA2QDeANMA4AD6ANkA/QD+APQBAgECAPYBBAEFAPcBDAEMAPkBDgEPAPoBkAGRAPwBlwGYAP4BmwGbAQABnQGeAQEBrAGsAQMBrgGvAQQBvQG9AQYBvwG/AQcB7wHwAQgABgAAADgAAAAyAAAALAAAACYAAAAgAAAAGgABAQsEXgABAl0EXgABAgUEXgABAekEXgABAZ4EXgABAPcEXgABAAYByQHKAcsBzAHyAfYABAAAAAEACAABA2oDAAABA14ADADsAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLoAugC4gLiAtwC3ALcAtwC3ALcAtwC3ALcAtwC3ALWAtAC0ALQAsoCygLKAtYC1gLWAtYC1gLWAtYC1gLWAtYCxALEAsQCvgK+Ar4CuAK4ArgCsgKyArICsgKyAqwCrAKsAqwCrAKsAqwCrAKsAqwCrAKsAqwCrAKsAqwCrAKmAqwCoAKgAqACmgKaApoClAKUAo4CjgKOAo4CjgKOAo4CjgKOAo4CjgKOAo4CjgLuAu4C7gKIAogCiAKIAogCggKCAnwCfAJ8AnwCfAJ8AnwCfAJ2AnYCdgJwAnACcAJwAnACcAJwAnACcAJwAmoCagJkAmQCZAJeAl4CXgJeAl4CXgJeAl4CXgJYAlICUgJSAkwCTAJMAkYCRgJGAkYCRgJGAkYCRgJGAkYCRgJAAjoCOgI6AjQCNAI0AjQCLgIuAi4CTAJMAkwCTAJMAmQCZAJkAmQCZAJkAmQCZAJkAmQCZAIoAigCIgI0AjQCNAIcAhwCHAIWAhYCFgIQAhACEAIQAhACEAIQAhACEAIKAgoCCgIEAgQCBAIEAgQB/gH+AfgB+AH4AfgB+AH4AfgB+AHyAfIB8gKaAewB5gHgAdoCvgABAo8AAAABAe0CmQABAcMCmQABAmUAvgABAiUAAAABA1gAAAABAi8AAAABA0YAAAABAj8AAAABAl4AAAABAXkAAAABAikAAAABA+/+XwABAPf+XwABA4AAAAABAPcAAAABAkUAAAABAL/+NwABAPkAAAABAl0AAAABAnD+RwABAUoAAAABAlsAAAABAmUAAAABApMAAAABAi0AAAABAn4AAAABArcAAAABAroAAAABA/EAAAABAvsAAAABApYAAAABApIAAAABAqUAAAABBboAAAABAxAAAAABAwQAAAABA5kAAAABAmsAAAABAsAAAAABAvgAAAABAwUAAAABARMAAAABAn8AAAABAnQAAAABAosAAAABAsIAAAACAA8AAgAMAAAAEAARAAsAFQAyAA0ANABTACsAVgCLAEsAjwCQAIEAkgCUAIMAlwCyAIYAtADNAKIAzwDXALwA2QDeAMUA4AD6AMsA/QD+AOYBkAGRAOgB7wHwAOoAAQAAAAYAAQD0AAAAAQABAc0AAgAAAAEACAABABAABAAAAAMAGgAaABoAAQADAWoBawFsAAEByv7pAAIAEAADFbYUzAAOAAAAAhA4AAQAABLsEQIALAAvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/eAAAAAAAAAAAAAP/pAAAAAP+YAAAAAAAAAAAAAAAA/9IAAAAA/7sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/jAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/dQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/68AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/owAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/6YAAAAA/4z/WAAAAAAAAAAAAAAAAP9M/8wAAAAAAAAAAAAAAAAAAP+Y/08AAAAAAAAAAP/JAAAAAAAAAAD/0gAAAAAAAAAA/+MAAAAAAAAAAAAA/7v/mAAA/7sAAP+6AAAAAP8v/17+9QAA/14AAAAA/2n/gAAAAAAAAAAAAAD/u/+7AAD/nP+7AAAAAAAA/28AAAAAAAD/dAAAAAAAAP9G//YAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/zsAAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/3UAAAAAAAAAAAAAAAAAAP9GAAAAAAAA/zsAAAAAAAAAAAAAAAAAAAAA/4D/jAAAAAD/jP+M/zUAAAAAAAAAAP+AAAAAAAAAAAAAAP+jAAD/OwAAAAD/UgAA/3X/6QAAAAAAAAAAAAAAAAAAAAAAAAAA/68AAAAAAAD/r/+AAAD+3gAAAAAAAAAAAAAAAAAAAAAAAP9YAAAAAAAAAAD/4gAAAAAAAAAAAAAAAAAA/4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/pv+vAAAAAP+7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9QAAAAAAAP+7AAAAAAAAAAAAAAAAAAAAAP+vAAAAAAAAAAAAAAAAAAAAAAAA/1L/gAAAAAAAAP+wAAAAAAAAAAAAAAAAAAD/gAAAAAAAAAAA/4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/OwAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/zv/i/4AAAAAA/+kAAP+7AAAAAAAAAAAAAAAAAAAAAAAAAAD/uwAAAAAAAP/pAAAAAAAA/5gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+n+6QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+jAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/pAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/7sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4gAAAAAAAAAAAAAAAAAAAAD/ugAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/ugAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/uwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/0v+YAAAAAAAAAAD/4gAAAAAAAAAAAAAAAAAAAAAAAP+7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/M/5gAAAAA/6MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAD/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/6gAAAAAAAAAAAAAAAAAAAAAAAAAA/7sAAAAAAAAAAAAA/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/sP/YAAAAAAAA//UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/1IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/rwAAAAAAAAAA/6MAAAAA/4AAAP+7AAAAAAAAAAD/mAAAAAD/mAAAAAAAAAAAAAAAAAAAAAAAAAAA/7sAAP+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//UAAAAAAAAAAAAA/8YAAAAAAAAAAAAAAAAAAP+bAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8j/t4AAAAAAAAAAAAAAAAAAAAAAAAAAAAA/4wAAAAA/7sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/3QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbgAAAAAAAAAA/68AAAAAAAAAAAAAAAAAAAAdAAD/rwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABdAAAAAAAAAAD/uwAAAAAAAAAAAAAAAAAA/7sAAP8A/t4AAAAAAAD/mAAAAAAAAAAAAAD/4AAA/4kAAAAA/4AAAAAAAAAAAAAAAAAAAAAA/94AAAAAAAAAAP/jAAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/7AAAAAAAAD/7gAA/78AAAAAAAAAAAAAAAAAAAAA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/68AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdAAAAAP+vAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABdAAAAAAAA/7sAAAAAAAAAAAAA/7oAAAAAAAAAAAAAAAD/u//DAAAAAAAAAAD/ugAAAAAAAAAAAAAAAP+7AAAAAAAAAAAAAAAA/6YAAP+vAAAAAAAAAAAAAP+7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/1AAAAAP+7AAAAAAAAAAAAAAAA/68AAAAAAAAAAP+6AB7/2AAAAAD/2P91AAD/af9S/7sAC/+YAAAAAAAAAAD/uwAAAAAAAP90AAAAAP91/4wAAP+6AAAAAAAAAAAAAP8v/17/af71AAD/XgAAAAD/af+AAAAAAAAA/7v/uwAA/5z/u/9vAAAAAP90AAAAAP9G//YAAAAAACgAAAAA/+wAAAAAAAAAAAAKAAAAAAAo/+z/4P+7/9gAAAAAAAAAAAAAAAD/6QAAAAAAFP/sAAAAAAAe/+wAAAAAAAAAAAAAAAD/zgAAAAAAAP+v/+wAAAAAAAAAAAAAAAD/4wAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/7sAAP9eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/4wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAggAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg/94AIAAA/68AIAAAAAAAAAAgAAAAAP+M/68AFAAAAAAAAAAgAAAAAP+7AAAAIAAAACAAAAARAAAARQAA/4AAAP9e/4wAIAAgAAAAAP+v/94AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABdAAAAAAAA/7sAAAAK/9gAAAAA/3UAHv/2AAAAAAAAAAD/u/+7/68AAP+vAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/6YAAP9e/4AAHgAAAAAAAAAA/9gAAAAAAAAAAAAAAAAAAAAA/68AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/4wAAAAA/2P/sP+7/2kAAP9v/68AAAAA/3UAAAAo/17/xv87AAAAAAAAAAD/rwAAAAAAAAAAAAD/gAAAAAAAAP+7/7sAAP8j/7sAAAAAAAAAAAAA/2MAAAAAAAAAAAAAAAD/dQAA/0b/gAAAAAAAAP/vAAAAAAAAAAAAAAAAAAD/rwAAAAAAAAAA/2D/jP/D/1L/L/9q/2kAAP+A/2kAKAAA/2kAAP+7AAAAAAAAAAD/uwAA/6MAAAAA/4D/u/+AAAAAuv/D/7sAAP8M/0YAAAAAAAAAAAAA/2AAAAAAAAAAAAAA/7v/dQAA/vX/mAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/af9e/14AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/af9pAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+jAAAAAAAA/7sAAAAAAAAAAP/iAAAAAAAAAAAAAP+YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/vAAAAAP+jAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/7sAAAAAAAAAAAAAAAD/Xv9pAAAAAAAAAAD/ugAAAAAAAAAAAAAAAP+Y/9IAAAAA/5gAAAAAAAAAAAAA/6MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/5gAAAAAAAAAAP+vAAD/O/+jAAAAAAAAAAD/mAAAAAAAAAAAAAAAAP91/7sAAAAA/4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARQAAAAAAAAAAAAAAAAAAAAAAAP+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+IAAAAAAAAAAAAAAAAAAAAAAAAAAP+7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+IAAAAAAAAAAP/2AAAAAAAAAAD/zwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/eAAAAAAAAAAAAXQAAAAAAAAAAAAAAAAAAAAAAAAAA/+IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/eAAAAAAAAAAAAAAAAAAAAAAAA/68AAP+7AAAAAAAA/7sAAP+vAAAAAAAA/yMAIP+7/+wAAAAAAAD/uwAAAAAAAAAAAAAAAP+AAAAArv+7AAAAAAAAAAAAAAAAAAAAAAAA/68AAAAAAAAAAAAAAAAAAAAA/5gAAAAAAAAAAP/iAAAAAAAA/+wAAAAAAAD/uwAAAAAAAAAA/9IAAAAAAAAAAAAAAAAAAAAAAAAAAP+M/6MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/9IAAAAAAAAAAAAAAAD/owAA/5gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/8YAAP+6AAAAAP+MAAAAAAAAAAAAAP+v/7oAAP+Y/+wAAAAAAAD/owAAAAAAAAAAAAAAAAAAAAAAAP+6AAAAAAAAAAAAAAAAAAAAAAAA/8YAAAAAAAAAAAAA/7r/rwAA/68AAAAAAAAAAP/y/9gAAAAA/+z/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAOgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/GAAD/0gAAAAAAAP91AAD/u/87/1IAAAAAAAAAAAAAAAD/uwAAAAAAAP91AAAAAAAAAAAAAP/GAAAAAAAAAAAAAP+w/0b/O/9SAAD+9QAAAAD/OwAAAAAAAAAA/4AAAAAA/0z/o/9bAAAAAP91AAAAAP7GAAAAAAAAAAAAAAAAAAAAAAAA/7sAAAAAAAAAAAAAAAD/o/+7AAAAAAAAAAD/owAAAAAAAAAAAAAAAP+vAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/9IAAAAAAAAAAAAAAAD/0v/DAAAAAAAAAAD/9QAAAAAAAAAAAAAAAP/SAAAAAAAAAAAARQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+7AAAAAAAAAAAAAAAAAAAAAAAA/68AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArv+7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/7sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/8QAAAAA/7v/uv/gAAAAAAAA/9IAFAAA/8YAAAAAAAAAAAAAAAD/0gAAAAAAAAAAAAAAAAAeAAAA0QAA/4wAAP9G/4D/sAAAAAAAAAAA/8QAAAAAAAAAAAAAAAD/gAAA/68AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/8YAAAAA/9IAAAAAAAAAKAAAAAAAAAAAAAAAAP+A/9IAAP+7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAAAAA/9IAAAAAAAAAAAAAAAAAAAAA/7sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/9sAAAAA/3UAAAAAAAAAAAAAAAAAAP+YAAAAAAAAAAAAAAAAAAAAAP+7AAAAAAAAAAAAAAAAAAAAAAAA/2kAAP9e/4wAAAAAAAAAAAAA/9sAAAAAAAAAAAAAAAAAAAAA/7sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/5j/ugAA/4wAAP+YAAAAAAAA/7sAAAAA/5gAAP+AAAAAAAAAAAAAAAAAAAAAAAAAAAD/mAAAADIAAAAA/zsAAP8j/4AAAAAAAAAAAAAA/5gAAAAAAAAAAAAAAAD/uwAA/4wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHgAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARQAAAAAAAAAAAAAAAAAAAAAAAAAA/5gAAP+7/3QAAP+YAAAAAAAA/6MAAAAA/5gAAP+AAAAAAAAAAAD/rwAAAAAAAAAeAAD/gAAAAAAArv+7/zsAAP8Y/zsAAAAAAAAAAAAA/5gAAAAAAAAAAAAA/+z/uwAA/4wAAAAAAAAAAAAAAAAAAAAeAAAAAAAAAAAAAAAA/5wAAAAA//UAAAAA/2kAAAAAAAAAAAAAAAAAAAAA/6MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/68AAP7e/zsAAAAAAAAAAAAA//UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4AAAARQAAAAAAaAAAAAAAAAAAAAAAAAC6AAAAggAAAAAAAAB4ACgAAAC6AAAAggCuAAAAAAAAAAABVAAAAAAAAAAAAAAAUQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXQAAAAAAAACuAAAAAAAAAAAAAAC6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP9eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+mAAAAAAAAAAAAAAAAAAD/u/+7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+6AB7/2AAAAAD/2P91AAD/af9SAAAACwAAAAAAAAAAAAAAAAAAAAAAAP90AAAAAP91/4wAAAAAAAAAAAAAAAAAAAAAAAD/aQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+7AAAAAP+YAAD/I/87AAAAAAAAAAAAAAAAAAAAAAAAAAAAAP9GAAAAAAAA/4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/6//xAAA/0YAAP/O/7sAAP+7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/7sAAAAAAAAAAAAAAAAAAAAA/68AAP8M/3UAAAAAAAAAAAAA/68AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/uwAAAAAAAAAA/4D/1f+M/ugAHf+M/68AAAAd/2MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+IAAAAA/14AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/q8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/7oAAAAAAAAAAAAAAAD/u//DAAAAAAAAAAD/ugAAAAAAAAAAAAAAAP+7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/7sAAAAA/2kAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/2kAAAAAAAAAAAAA/7sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/7AAAAAA/zsAAAAAAAAAAAAA/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/tIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/7sAAAAUAAAAAP/YAAD/Uv9gAAAAAAAAAAD/xgAAAAAAAAAA/+IAAP+Y/9IAAP/b/5gAAAAAAAAAAAAAAAAAAAAAAAD/uwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/p/14AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/zsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+kAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/7sAAAAA/2kAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/2kAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHgAAAAAAAAAAAAD/uwAAAAAAAAAAAAD/ugAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/7sAAAAAAAAAAAAAAAD/gP+YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/7sAAAAAAAAAAP+7AAD/Rv71AAAAAAAAAAD/rwAAAAAAAP+7AAAAAP+A/7sAAP+7/4wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP91AAAAAAAAAAAAAAAAAAAAAAAAAAAAAP9gAAAAAAAA/2oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/8YAAP/1/28AAP/pAAAAAAAA/+n/7wAAAAAAAAAAAAD/8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/28AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/0YARQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/xgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/jP+YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/5j/mAAA/yMAAP+jAAAAAAAA/68AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAugAAAAAAAAAA/zsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/84AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAbAAIA+gAAAPwA/gD5AQIBAwD8AQUBBgD+AQkBCwEAASEBIQEDASMBIwEEASUBJQEFASgBKAEGATUBPAEHAUIBSwEPAU0BTQEZAU8BTwEaAVQBVQEbAVcBWAEdAVsBXAEfAV8BZwEhAWoBbQEqAW8BdAEuAXcBfQE0AYABhgE7AYkBlAFCAZYBlgFOAbQBtAFPAdMB1gFQAeIB5QFUAe8B7wFYAAIAhQACAA8ABQAQABEAAQASABQABAAVACIAAQAjACUABAAmACkAAQAqACsAFAAsAC0AAQAuADAAFAAxADIAAQAzADMAIwA0AEEAAQBCAFMABABUAFUAAQBWAFYABABXAFkAAQBaAFwAEQBdAF4ADQBfAGwACQBtAG8AGQBwAHQAHQB1AHYAEgB3AH4ADAB/AIEAFgCCAI4ABwCPAJEAAQCSAJ8AAgCgAKAAJAChAKMAAgCkAKYAAQCnAKgADwCpAKoAHgCrAK0ADwCuAK4AHgCvALEADwCyALMAGAC0ALoAAQC7AMIAAwDDAM4AAgDPANAAAwDRANEAAgDSANQAAwDVANcACwDYANgAAQDZANsABgDcAN4ACADfAN8APwDgAOUACADmAOgACgDpAO0AHADuAO8AGgDwAPcACgD4APoAFwD7APsAAQD8APwAAgD9AP0AOwD+AP4AKQECAQIALwEDAQMANgEFAQUAOAEGAQYAMAEIAQgALwEJAQkAQAEKAQoAPAEiASIAIQEkASQAIQEmASYAIQEoASgADgE1ATUAEAE2ATcADgE4ATgAFQE5ATkADgE6AToAEAE7ATsADgE8ATwAFQFCAUIALgFDAUMANAFEAUQAKwFFAUUALAFGAUYAKwFHAUcALAFIAUgAKwFJAUkALAFKAUoAHwFMAUwAIQFOAU4AIQFQAVAAIQFUAVQAQQFVAVUAEwFXAVcAOgFYAVgADgFbAVsAFQFcAVwADgFfAV8AFQFgAWAAKAFhAWEAJQFiAWMAJgFkAWQAKAFlAWUAJQFmAWcAIgFqAWwAIAFtAW8AGwFwAXAADgFxAXEAMgFyAXIAMwFzAXMAMgF0AXQAMwF3AXcAEAF4AXkADgF6AXoAFQF7AXsADgF8AXwAEAF9AX0ADgGAAYAAEAGBAYIADgGDAYMAFQGEAYQADgGFAYUAEAGGAYcADgGJAYoAKgGLAYsAFQGMAYwANwGNAY0AHwGOAY4ALQGPAY8AKgGQAZMAJwGUAZQANQGZAZkAMQGaAZoAPgG0AbQAPQHXAdkADgHaAdsAEAHvAe8AOQACAIcAAgAMAAUADQAPAAcAEAARABIAEgAUABkAFQAWAAQAFwAhAAcAIgAiAC0AIwAlAB0AKgArABgALgAwABgAMwAzAAgANAA2ABUANwA5ABoAQgBSAAQAUwBTAAcAVABVACUAVgBWAAQAVwBZABQAWgBcABEAXQBeAA0AXwBsAAgAbQBvACQAcAB0ACIAdQB2ABcAdwB+AAwAfwCBAB4AggCLAAIAjACOACcAjwCUAAEAlwCfAAEAoACgAB8AoQCjABwApACmAAIApwCoAAkAqQCqACYAqwCtAAkArgCuACYArwCzAAkAtAC2ABYAuwDCAAIAwwDQAAEA0QDRABwA0gDUAAoA1QDXAA4A2ADYABIA2QDbAAYA3ADeAAMA3wDfAEMA4ADlAAMA5gDoAAsA6QDtACEA7gDvACAA8AD3AAsA+AD6ABMA/AD8AAEA/QD9AEEA/gD+ADMBAgECADoBAwEDACMBBQEFADgBBgEGADsBCQEJAEQBCgEKADgBCwELADoBIQEhACsBIwEjACsBJQElACsBKAEoAA8BNQE1ABABNgE3AA8BOAE4ABsBOQE5AA8BOgE6ABABOwE7AA8BPAE8ABsBQgFCADkBQwFDAD4BRAFEADUBRQFFADYBRgFGADUBRwFHADYBSAFIADUBSQFJADYBSgFKADABSwFLACsBTQFNACsBTwFPACsBVAFUAEUBVQFVACMBVwFXACoBWAFYAA8BWwFbABsBXAFcAA8BXwFfABsBYAFgADIBYQFhAC4BYgFjAC8BZAFkADIBZQFlAC4BZgFnACwBagFsACkBbQFtACgBbwFvACgBcAFwAA8BcQFxADwBcgFyAD0BcwFzADwBdAF0AD0BdwF3ABABeAF5AA8BegF6ABsBewF7AA8BfAF8ABABfQF9AA8BgAGAABABgQGCAA8BgwGDABsBhAGEAA8BhQGFABABhgGGAA8BiQGKADQBiwGLABsBjAGMAEABjQGNADABjgGOADcBjwGPADQBkAGTADEBlAGUACMBlgGWAD8BtAG0AEIB0wHVAA8B1gHWABAB4gHkAA8B5QHlABAB7wHvAAQAAQACAAAACAABAKIABAAAAEwETARMBEwETARMBEwETARMBEwETARMBEYERgRGBEYERgRGBEYERge2A+wGCgRGBEYERgRGBEYERgRGBEYD3gPQA8oDygPKA8oDygPEA8QDsgOyA7IDsgOyA7IDsgOyA6gERgRGA5oDmgN4A5oDmgNmAzwDBgOaA5oDmgOaBEYERgRGBEYC/AL8AvwC2gLMAqoCoAJmAlwBHgACABQAAgAMAAAAJgApAAsALAAtAA8AMQAyABEANwBBABMAXQBeAB4AcAB+ACAAiQCJAC8AlQCWADAApwCoADIAqgCzADQAtwC6AD4A0gDUAEIA/wD/AEUBBwEHAEYBVwFXAEcBcAFwAEgBdgF2AEkBfQF9AEoBiAGIAEsATwAQAEUAEQBFABUARQAWAEUAFwBFABgARQAZAEUAGgBFABsARQAcAEUAHQBFAB4ARQAfAEUAIABFACEARQAiAEUAJgBFACcARQAoAEUAKQBFACwARQAtAEUAMQBFADIARQA0AEUANQBFADYARQA3AEUAOABFADkARQA6AEUAOwBFADwARQA9AEUAPgBFAD8ARQBAAEUAQQBFAFQARQBVAEUAVwBFAFgARQBZAEUAjwBFAJAARQCRAEUApABFAKUARQCmAEUApwBFAKgARQCrAEUArABFAK0ARQCvAEUAsABFALEARQC0AEUAtQBFALYARQC3AEUAuABFALkARQC6AEUAuwBFALwARQC9AEUAvgBFAL8ARQDAAEUAwQBFAMIARQDPAEUA0ABFANIARQDTAEUA1ABFANgARQD7AEUAAgB1/7oAdv+6AA4AAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAACAF3/XgBe/14ACABt/5wAbv+cAG//nABw/4wAcf+MAHL/jABz/4wAdP+MAAMA2QAAANoAAADbAAAACACnAEUAqABFAKsARQCsAEUArQBFAK8ARQCwAEUAsQBFAAIBdf+vAYf/uwANAKcAAACoAAAAqQBFAKoARQCrAAAArAAAAK0AAACuAEUArwAAALAAAACxAAAA/wAAAYgAAAAKAKcAUQCoAFEAqwBRAKwAUQCtAFEArwBRALAAUQCxAFEAsgBRALMAUQAEAKkARQCuAEUA/wAAAYgAAAAIAKcAUQCoAFEAqwBRAKwAUQCtAFEArwBRALAAUQCxAFEAAwCqAEUA/wAAAYgAAAACAF3/aQBe/2kABACF/5wAif+hAIv/bwCs/8YAAQF9/7oAAQFw/7sAAwDu/4AA7/+AAXD/XgADAN3/mAD6/7sBcP9eABYAfP+7AH3/uwB+/7sBKP+YATb/mAE3/5gBOf+YATv/mAFY/5gBXP+YAXD/mAF4/5gBef+YAXv/mAGB/5gBgv+YAYT/mAGG/5gBh/+YAdf/mAHY/5gB2f+YAAEBiAAAAAEBdQAAAAEAAgAAAAgAAQEKAAQAAACABzYHNgc2BzYHNgcoByIHFAcUBxQG+gboBsoHNgc2BzYHNgc2BzYHNgc2BzYHNgc2BzYHNgc2BzYHNgc2BrwGvAc2Bn4GFAciByIHIgciByIHIgciByIHIgciByIHIgciByIF8gXEBcQFugW6BboFugW6BawFrAWOBY4FjgWOBY4FaAVoBWgFXgVeBV4FVAVKBUAFOgUwBTAFMAUqBSAFIAUgBRYFEAUQBRAFAgUCBQIFAgUCBQIFAgUCBQIE9AT0BPQE7gTuBO4E7gTuBPQE9AT0BPQE9AT0BPQE9ARwA9YDoANqA1wDXANcAyYCyAK+BSAB2AHSAdIB0gHSBzYBsAACABsAEgAWAAAAIgAiAAUAMwA5AAYAQgBSAA0AVABWAB4AXQCBACEAoACgAEYAqQCqAEcArQCtAEkAtAC2AEoAuAC4AE0AvwC/AE4AxADFAE8A2ADeAFEA4ADtAFgA8AD3AGYA+wD7AG4BPwE/AG8BQQFBAHABVwFXAHEBagFsAHIBcAFwAHUBdgF2AHYBegF6AHcBhwGIAHgBkAGTAHoB7wHwAH4ACAB3/7sAeP+7AHn/uwB6/7sAe/+7AHz/uwB9/7sAfv+7AAEBP/+vADkAEv+vABP/rwAU/68AI/+vACT/rwAl/68AQv+vAEP/rwBE/68ARf+vAEb/rwBH/68ASP+vAEn/rwBK/68AS/+vAEz/rwBN/68ATv+vAE//rwBQ/68AUf+vAFL/rwBT/68AVv+vAF3/jABe/4wAX/+vAGD/rwBh/68AYv+vAGP/rwBk/68AZf+vAGb/rwBn/68AaP+vAGn/rwBq/68Aa/+vAGz/rwBt/14Abv9eAG//XgCyAMUAswDFAOb/XgDn/14A6P9eAPD/XgDx/14A8v9eAPP/XgD0/14A9f9eAPb/XgD3/14AAgBd/4wAXv+MABcAXf9eAF7/XgBt/2kAbv9pAG//aQBw/2kAcf9pAHL/aQBz/2kAdP9pAHX/jAB2/4wAd/9GAHj/RgB5/0YAev9GAHv/RgB8/0YAff9GAH7/RgB//4AAgP+AAIH/gAANAG3/rwBu/68Ab/+vAHX/owB2/6MAd/+YAHj/mAB5/5gAev+YAHv/mAB8/5gAff+YAH7/mAADAHz/uwB9/7sAfv+7AA0AXf+vAF7/rwDm/5gA5/+YAOj/mADw/5gA8f+YAPL/mADz/5gA9P+YAPX/mAD2/5gA9/+YAA0AXf91AF7/dQBt/7sAbv+7AG//uwB3/3UAeP91AHn/dQB6/3UAe/91AHz/dQB9/3UAfv91ACYAXf+MAF7/jABt/4AAbv+AAG//gABw/68Acf+vAHL/rwBz/68AdP+vAHf/aQB4/2kAef9pAHr/aQB7/2kAfP9pAH3/aQB+/2kA5v+7AOf/uwDo/7sA6f+7AOr/uwDr/7sA7P+7AO3/uwDw/7sA8f+7APL/uwDz/7sA9P+7APX/uwD2/7sA9/+7AZD/rwGR/68Bkv+vAZP/rwAfAAL/rwAD/68ABP+vAAX/rwAG/68AB/+vAAj/rwAJ/68ACv+vAAv/rwAM/68ADf+vAA7/rwAP/68AM/+vAF3/jABe/4wAbf+YAG7/mABv/5gAf/+vAID/rwCB/68BV/+YAWD/jAFk/4wBZv8AAWf/AAFq/y8Ba/8vAWz/LwABAT//uwADAWz/aQF1/7sBiP9eAAMBdf+vAYf/uwGI/7sAAQF1/8YAAgFg/3UBZP91AAIAXf+YAF7/mAABAe8ARQACAXX/UgGH/3UAAQCqAFEAAgCyAEUAswBFAAIAqwBFAK0ARQACAK4AUQGI/+MAAgFw/7sBdf+AAAkAyv+MAT//gAFq/7sBa/+7AWz/uwFw/5gBdf8vAXr/owGH/5gABwDK/4wBP/+AAWz/OwFw/5gBdf8vAXr/owGH/5gAAwFw/6MBdf+MAYf/mAACAT//mAF1/2kACwCF/68Axf+jAT//mAFK/7sBav+7AWv/uwFs/7sBcP+vAXX/aQGH/4ABiP9eAAgAhf+vAMX/owE//5gBSv+7AXD/rwF1/2kBh/+AAYj/XgAaAIX/rwCL/68AmP+YAMT/mADF/5gA3P+7AN3/uwDe/7sA3/+7AOD/uwDh/7sA4v+7AOP/uwDk/7sA5f+7AOr/mADx/7sA+P+7APn/uwD6/7sBP/+7AVT/mAFs/1IBbv+vAXX/XgGI/4wADwCF/68Ai/+vAJj/mADE/5gAxf+YAN7/rwDf/y8A6v+YAPH/uwE//7sBVP+YAWz/UgFu/68Bdf9eAYj/jAADAT//uwFr/7sBbP87AAcBWP+YAXD/gAF9/68Bh/71AYn/owGK/6MBj/+jAAQBff+jAYn/owGK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) format('truetype');
}
p, ul, a, ol {
font-family: var(--main-font);
}
h1, h2, h3, h4 {
font-family: var(--header-font);
}


h1, h2, h3, h4 {
color: var(--main-color)
}
h1.title, h1.subtitle, h2.author, h2.date {
color: #ffffff;
}

h1.title {
font-size: 50pt;
margin-right: 15%;
font-weight: 700;
}
h1.subtitle {
margin-right: 15%;
font-size: 25pt;
}
h2.author {
margin-top: 70%;
font-size: 25pt;
}
h2.date {
font-size: 25pt;
}

h1 {
font-size: 40pt;
}
h2 {
font-size: 24pt;
}

p, ul, ol {
margin-right: 15%;
}


.level1 {
break-before: page;
}
.section > h1, .section > h2, .section > h3, .section > h4, .section > h5, .section > h6 {
break-after: avoid;
}
.footenotes {
break-before: always;
break-after: always;
}
.figure {
break-inside: avoid;
}

caption {
break-inside: avoid;
break-after: avoid;
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">.</h1>
<h1 class="subtitle"><span>- Agencia Federal de Inteligencia</span></h1>
<h2 class="author"></h2>
</div>

<div class="main-color" style="display: none;">#6BA09D</div>
<script>
(function() {
    let mainColor = document.querySelector('.main-color');
    let mainColorCont = mainColor.textContent;
    document.documentElement.style.setProperty('--main-color', mainColorCont);
})();
</script>




</div>

<div class="front-matter-container">
</div>

<div class="main">
<div id="introduccin" class="section level2 unnumbered">
<h2>Introduccin</h2>
<p>La Ley N 27.275 de Derecho de Acceso a la Informacin Pblica tiene por objeto garantizar el efectivo ejercicio del derecho de acceso a la informacin pblica, promover la participacin ciudadana y la transparencia de la gestin pblica. En su artculo 32 establece un estndar de transparencia al exigir que los sujetos obligados faciliten la bsqueda y el acceso a la informacin pblica a travs de su pgina oficial de la red informtica, de una manera clara, estructurada y entendible para los interesados y procurando remover toda barrera que obstaculice o dificulte su reutilizacin por parte de terceros.</p>
<p>La Direccin Nacional de Evaluacin de Polticas de Transparencia (DNEPT) de la Agencia de Acceso a la Informacin Pblica (AAIP) monitorea qu, cmo, con qu frecuencia y cunta informacin pblica disponibilizan los sujetos obligados en sus respectivos sitios web oficiales a travs del ndice de Transparencia. Esta herramienta de gestin busca contribuir al fortalecimiento de las polticas de transparencia en el Poder Ejecutivo Nacional, as como coadyuvar al monitoreo que la sociedad realiza sobre la gestin pblica.</p>
<p>En el presente informe se presentan los resultados alcanzados por Agencia Federal de Inteligencia.</p>
</div>
<div id="metodologa" class="section level2 unnumbered">
<h2>Metodologa</h2>
<p>El ndice releva 20 tems, de los cuales 13 son de Transparencia Activa y 7 de Transparencia Proactiva. Cada dimensin tiene 3 indicadores empricos (observables) especficos en los que se punta la forma en la que se muestra, publica o explicita la informacin encontrada:</p>
<ol style="list-style-type: decimal">
<li>Completitud: observa que la informacin est disponible en forma completa;</li>
<li>Actualizacin: observa que la informacin est actualizada; y,</li>
<li>Disponibilidad: observa que la informacin sea de fcil acceso y localizacin; incluye que se pueda descargar en un formato verstil y que la informacin est emplazada en un apartado especfico de la pestaa de transparencia o en el Portal Nacional de Transparencia.</li>
</ol>
<p>El ndice alcanza al total de sujetos obligados con una frecuencia de medicin semestral, aunque en trminos operativos se releva de manera trimestral al 50% del universo de sujetos obligados.
El valor del ndice se compone del promedio ponderado de los subndices de Transparencia Activa (TA) y Transparencia Proactiva (TP). Cabe aclarar, que el subndice TA aporta el 90% del valor del ndice de Transparencia (IT), mientras que el subndice TP aporta el 10% restante. La frmula es la siguiente:</p>
<p><span class="math inline">\(IT = ((subndice TA * ponderador)) + ((subndice TP * ponderador))* 100\)</span></p>
<p>Asimismo, los subndices se pueden reportar de manera independiente siendo valor de ellos estimados como el promedio ponderado de los tems que los componen. Las frmulas son las siguientes:</p>
<p><span class="math inline">\(TA = ((tem 1 * ponderador) + (tem 2 * ponderador) + ... (tem 13 * ponderador)) * 100\)</span></p>
<p><span class="math inline">\(TP = ((tem 14 * ponderador) + (tem 15 * ponderador) + ... (tem 20 * ponderador)) * 100\)</span></p>
</div>
<div id="resultados-del-ndice-de-transparencia" class="section level2 unnumbered">
<h2>Resultados del ndice de Transparencia</h2>
<p>A continuacin, se detallan los resultados obtenidos por el organismo en la medicin.</p>
<p><img src="data:image/png;base64,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/BXw7bffrva981VVVY0bN5bL2yZ/8/uKLl68eOjQIZXP3bJli8rUvn37ygN//PFHDd/8XHN9+vSRBwoKCszfJrVifnJy69atVYrt3LlT2891nCbbolu3bvLAsWPHrl27plJy+/btejfGKV6ygcRdgW5gvp+8qqpKvaTHF58e0llecgACAABopaYB3hzCDQbDM888U/3n+fg8/fTT8vDOnTvNz66XDRs2zPyQrYULF9qr5Ndff92zZ4/Kpzz22GMBAQHy8Pz586ttla4sG/Puu+9qW7n5eUsqd2+aTKYPP/xQ2891nCbbYsiQIfKA0WhctWqVvWK3bt36+uuv9W6MU7xkA4m7At3A/Oy0at8f5vHFp4d0lpccgAAAAFqpUYAvKytbv369PNyrV6/mzZs7Mpc551u+PV5Wr169UaNGycObNm2ymiq7devW2LFj1R8UHBERMWHCBHl4zZo1X3zxRbWtqqioqPb5Xq5p2LDh6NGj5eGdO3d+8MEHGlberFkzeWD37t32vqEuXrw4LS1Nww91iibbok2bNomJifLwu+++K9++a2vatGnqD/dy/47hJRtI3BXoBvfcc488kJWVpf4IAI8vPj2ks7zkAAQAANBKjQL85s2bzQ/+GTlypINzJSQkmO/AXLVqldUXzfnz54eHh8vD48ePf+2118zXQFZWVm7btq179+4nTpxo1aqV+qfMnj07NjZWHh47duyMGTPs3eJ44cKFhQsXxsbGnjx50sFFcNa8efPMD+f/y1/+8uabb5aUlNgWO378+NixY9PT0x2vuX///vLArVu3xo8fb/U0waqqqvfee2/q1KmSJJnfluR+mmyLhQsXyq+Szs/PHzBgwJkzZyynGo3Gt956a8WKFdW+1NrNO4b3bCBBV6AbdO/eXV5qk8k0depU9Z8wPL749JB3Xg8JAADguBo9hd78+vfatWsPHz7c8RlHjBgxc+ZMSZLOnTu3Z8+eP/3pT+ZJ4eHhX3755aBBg0pLS41G4+LFi99///0mTZoEBQVdvnxZ/ooZFBS0bt068229ii83ql+//pYtWx566KGcnByj0Thv3rxly5Y9+uijXbp0adCgQWVlZW5u7smTJ9PS0qp9rFfNRURErF+/fuDAgfIprAULFqxYsWLw4MHt27cPCwsrLCw8depUcnJyRkaGJEmTJk1yvOZhw4a1adNG/mK9cePG1NTU0aNHt23btrKy8tSpU5s2bTpx4oQkSePGjdu1a5f8NGb302Rb9O7de/LkyfLZuePHj3fo0CEpKalXr15BQUFnz55dv369/PS1v/71r++8847ejXGc92wgQVegGzRt2vSRRx6Rb/5fvXr1unXrmjdvbn7RWteuXS2f0+7xxaeHvPN6SAAAACdU+9g5e86ePWs+WTd48GCn5j19+rS5ASNHjrQtsGfPHvOlj1aaN2+elpYmvzdYlpKSYu+D/vjjj3bt2jm4Ko4cOWI1+/jx4+VJvXv3Vl+iFi1ayCXnzp1rr8yBAwciIyOrbUZqaqrVjHPnzpUnxcTE2Fb7+++/K77W2GzgwIFlZWUxMTHVtlCd+XYJSZLWr1/v7Ow13BYmk6mqqsp8qa2ipKQky9uYt23bplNjHN8xTBptIPV9wEHeswIdUe3+puHhefbsWfPpaCsPPPCAbfkaLr761nRkW9NDOr7G3NZDAgAAuIHrFw2uXLnS9N+r3x15fJ2lli1b3nffffLwli1bbJ8d9eCDDx47dmzJkiV9+vSJjIz08/Nr2rRp3759P/744yNHjiQkJOTm5poL161b194HtWjRIj09/bPPPmvfvr29Mu3atZs6deqRI0dUymiie/fup0+fnjFjhr0vqXFxcfPnz4+Li3Oq2vj4+EOHDg0ePNj24ufmzZsvXbr0u+++8/f3d7HR2qn5tvDx8fn8889XrlwZHR1tNalx48ZLly5dv369g9fBunPH8J4NJOgKdIPY2NiMjIwlS5b079+/cePG5gfF2ePxxaeHdJz3HIAAAAA1ZzCpPuvIa3377bdDhw6VJMnHx6egoCAoKKjaWa5evXrgwIHr16/n5OT4+fmFhYW1bNkyPj7efEOp25hMpsOHDx89evTmzZu3b98OCQlp3rx5586dmzRpUpNqL126lJycLN8Q26hRo9atW993333V3tLsETXcFkajMTk5+cSJEzk5OZGRkS1btkxMTHT5Fla37Rjes4EEXYHeyTsXnx7SlvccgAAAAC4TNcBPmjRp+fLlkiTde++9x44d83RzAMCL0EMCAADckYR87u7169fN7z169NFHPdsYAPAq9JAAAAB3Km8M8KdPny4rK7M3taioaMSIEQUFBfKf5rcZA8DdgB4SAADgruWNAX7jxo0tWrSYNWvW0aNHjUajeXxRUdGGDRu6du26Z88eecyLL77o7AONAEBo9JAAAAB3LW+8B37evHkzZsyQh4ODg5s2bRoYGJiXl3fhwoXKykpzsZ49e+7YscORhzMBwB2DHhIAAOCuVcvTDVDg6+trHi4qKsrMzLQqUKtWreeee27JkiXVvu0JAO4w9JAAAAB3LW88A280Gvft27dz586DBw/+8ccfWVlZJSUl/v7+9evXb9Wq1YMPPjhy5MgWLVp4upkA4AH0kAAAAHctbwzwAAAAAADAijc+xA4AAAAAAFghwAMAAAAAIAACPAAAAAAAAiDAAwAAAAAgAAI8AAAAAAACIMADAAAAACAAAjwAAAAAAAIgwAMAAAAAIAACPAAAAAAAAiDAAwAAAAAgAAI8AAAAAAACIMADAAAAACAAAjwAAAAAAAIgwAMAAAAAIAACPAAAAAAAAiDAAwAAAAAgAAI8AAAAAAACqOXpBsAzTCbTsWPHSkpKJEnq0qVLrVrsCUD1TCZTVVWVPOzj4+Pjw2+gQPUsDxxfX1+DweDZ9gBC4MABXGA0Go1Gozx8px44BpPJ5Ok2wAMqKyu7du2akZEhSdLNmzfDw8M93SJAABUVFfn5+fJwcHBwQECAZ9sDCKG8vLygoEAeDgkJ8ff392x7ACHcvn27sLBQHg4NDfXz8/NsewAhlJWVFRUVycN169atXbu2Z9ujB04fAQAAAAAgAAI8AAAAAAACIMADAAAAACAAAjwAAAAAAAIgwAMAAAAAIAACPAAAAAAAAiDAAwAAAAAgAAI8AAAAAAACIMADAAAAACAAAjwAAAAAAAIgwAMAAAAAIAACPAAAAAAAAiDAAwAAAAAgAAI8AAAAAAACIMADAAAAACAAAjwAAAAAAAIgwAMAAAAAIAACPAAAAAAAAiDAAwAAAAAgAAI8AAAAAAACIMADAAAAACAAAjwAAAAAAAIgwAMAAAAAIAACPAAAAAAAAiDAAwAAAAAgAAI8AAAAAAACIMADAAAAACAAAjwAAAAAAAIgwAMAAAAAIAACPAAAAAAAAiDAAwAAAAAgAAI8AAAAAAACIMADAAAAACAAAjwAAAAAAAIgwAMAAAAAIAACPAAAAAAAAiDAAwAAAAAgAAI8AAAAAAACIMADAAAAACAAAjwAAAAAAAIgwAMAAAAAIAACPAAAAAAAAiDAAwAAAAAgAAI8AAAAAAACIMADAAAAACAAAjwAAAAAAAIgwAMAAAAAIAACPAAAAAAAAiDAAwAAAAAgAAI8AAAAAAACIMADAAAAACAAAjwAAAAAAAIgwAMAAAAAIAACPAAAAAAAAiDAAwAAAAAgAAI8AAAAAAACIMADAAAAACAAAjwAAAAAAAIgwAMAAAAAIAACPAAAAAAAAiDAAwAAAAAgAAI8AAAAAAACIMADAAAAACAAAjwAAAAAAAIgwAMAAAAAIAACPAAAAAAAAiDAAwAAAAAgAAI8AAAAAAACIMADAAAAACAAAjwAAAAAAAIgwAMAAAAAIAACPAAAAAAAAiDAAwAAAAAgAAI8AAAAAAACIMADAAAAACAAAjwAAAAAAAIgwAMAAAAAIAACPAAAAAAAAiDAAwAAAAAgAAI8AAAAAAACIMADAAAAACAAAjwAAAAAAAIgwAMAAAAAIAACPAAAAAAAAiDAAwAAAAAgAAI8AAAAAAACIMADAAAAACAAAjwAAAAAAAIgwAMAAAAAIAACPAAAAAAAAiDAAwAAAAAgAAI8AAAAAAACIMADAAAAACAAAjwAAAAAAAIgwAMAAAAAIAACPAAAAAAAAiDAAwAAAAAgAAI8AAAAAAACIMADAAAAACAAAjwAAAAAAAIgwAMAAAAAIAACPAAAAAAAAiDAAwAAAAAgAAI8AAAAAAACIMADAAAAACAAAjwAAAAAAAIgwAMAAAAAIAACPAAAAAAAAiDAAwAAAAAgAAI8AAAAAAACIMADAAAAACAAAjwAAAAAAAIgwAMAAAAAIAACPAAAAAAAAqjl6Qa4Ljc399lnn3VhxjfeeKN3797FxcUjRoywmmQwGOrUqRMWFtaqVav7778/ISHBYDBo0VgAAAAAAGqEM/D/PyaTqaSk5MqVKz/99NOcOXOmT5+el5fn6Ua5VVVV1T/+8Y8+ffo0aNAgJCSkU6dOc+fOLSws9HS7AAAAAOBuJ/AZ+Dp16jzxxBO24y9evJiamipJ0j333NO5c2fbAk2aNLH8MygoyLKegoKCY8eOnT59WpKko0ePzp49e9GiRb6+vhq33itlZ2cPHDhQXnuyjIyMjIyMf/zjHz/++GO7du082DYAAAAAuMsJHOADAgIUL6H/6aef5AjaunVrR66xDwoKevLJJ61GJicn//3vfzcajWfOnNm5c2f//v01abM3MxqNQ4YMkVfdgAEDnnrqKT8/v507d65evfry5cv9+vU7duxYvXr1PN1MAAAAALhLcQm9sj59+gwePFge3rt3r2cb4x6fffbZgQMHJEl67bXXvv/++7Fjxz7zzDMrV65ctWqVJElXr16dNWuWh5sIAAAAAHcxArxdvXr1kgcuXLjg2Za4x9KlSyVJatas2YIFCyzHjxkzpl+/fpIkrVixoqSkxDONAwAAAIC7HgHeLvPl4sXFxZ5tiRucOHHi6NGjkiSNGTOmdu3aVlMnTJggSVJxcfG///1vDzQOAAAAAECAV2F+/nxgYKBnW+IGBw8elAf69u1rO/WBBx6wKgYAAAAAcDMCvF379u2TB2JiYjzbEjeQT79LkqT4qPmIiIgGDRpIknTs2DG3NgsAAAAA8F8CP4VeV8nJyd9995083Lt3bxdqKC8v9+Zr700mk3m4tLRUvs+/du3atWvXzs3NtS0fFRV169atixcvKk4F7hKWB05JSUlpaakHGwOIwvLAKS4u5nEqgCMsD5yioiKDweDBxgCisDxwCgsLvfnACQwM9Pf3d2FGArxUXFz81Vdfmf8sLCw8evSo/B54SZJiY2MffvhhF6o1mUxVVVXaNFFnJpOpqKhIkqTAwECj0ahYRr6PoLi4WJSFAvRm72ABoIIDB3ABBw7gAi8/cCx/a3AKAV4qLi7+/PPPFSfFxcVNmzatVq07fy3JJxJtH19n5ufnJ90dz/MDAAAAAO9050dTpxgMhoCAgPr167ds2bJPnz7dunVz+boLg8Hgzcnf8icfHx+fgIAASZIqKyvttbm8vFySJH9/f29eKEBvllfW+Pj4+PjwGBGgehw4gAs4cAAXGI1G84l3X19fb76E3uWDmjAmRURErFixQvNq/fz85LPW3qmystI8HBAQEBYWJklSSUmJ+eV5Vm7fvi1JUt26de0VAO4GFRUV+fn58nBgYKD8yxcAdeXl5QUFBfJwUFCQa7f8AXeb27dvFxYWysPBwcHe/K0S8B5lZWXyrcGSJAUHB6tcXywufsyDJElSkyZNJEkqLy+/efOmYoGrV69KkhQVFeXWZgEAAAAA/osAD0mSpLZt28oDJ0+etJ2am5srB3vFl8wBAAAAANyAAA9JkqSePXvKA8nJybZTU1JSrIoBAAAAANyMAA9JkqS2bdu2atVKkqQ1a9bYvtJg7dq1kiT5+fkNGDDAA40DAAAAABDgYTZlyhRJko4fP/7RRx9Zjt+zZ8+XX34pSdL48eNDQ0M90zgAAAAAuOvxFHr8nwkTJnz22WeHDh165ZVXzp8/P3z48Fq1am3fvn3u3LkmkykqKuqtt97ydBsBAAAA4O5FgMf/8fPz++abbwYMGHDs2LFFixYtWrTIPCkqKmrbtm2NGjXyYPMAAAAA4C7HJfT4/zRt2jQtLW3RokVdu3atV69eUFDQvffe+7e//e33339PSEjwdOsAAAAA4K5msH1iGe4GlZWVXbt2zcjIkCTp5s2b4eHhnm4RIICKior8/Hx5ODg4OCAgwLPtAYRQXl5eUFAgD4eEhPj7+3u2PYAQbt++XVhYKA+Hhob6+fl5CM27zAAAIABJREFUtj2AEMrKyoqKiuThunXr1q5d27Pt0QNn4AEAAAAAEAABHgAAAAAAARDgAQAAAAAQAAEeAAAAAAABEOABAAAAABAAAR4AAAAAAAEQ4AEAAAAAEAABHgAAAAAAARDgAQAAAAAQAAEeAAAAAAABEOABAAAAABAAAR4AAAAAAAEQ4AEAAAAAEAABHgAAAAAAARDgAQAAAAAQAAEeAAAAAAABEOABAAAAABAAAR4AAAAAAAEQ4AEAAAAAEAABHgAAAAAAARDgAQAAAAAQAAEeAAAAAAABEOABAAAAABAAAR4AAAAAAAEQ4AEAAAAAEAABHgAAAAAAARDgAQAAAAAQAAEeAAAAAAABEOABAAAAABAAAR4AAAAAAAEQ4AEAAAAAEAABHgAAAAAAARDgAQAAAAAQAAEeAAAAAAABEOABAAAAABAAAR4AAAAAAAEQ4AEAAAAAEAABHgAAAAAAARDgAQAAAAAQAAEeAAAAAAABEOABAAAAABAAAR4AAAAAAAEQ4AEAAAAAEAABHgAAAAAAARDgAQAAAAAQAAEeAAAAAAABEOABAAAAABAAAR4AAAAAAAEQ4AEAAAAAEAABHgAAAAAAARDgAQAAAAAQAAEeAAAAAAABEOABAAAAABAAAR4AAAAAAAEQ4AEAAAAAEAABHgAAAAAAARDgAQAAAAAQAAEeAAAAAAABEOABAAAAABAAAR4AAAAAAAEQ4AEAAAAAEAABHgAAAAAAARDgAQAAAAAQAAEeAAAAAAABEOABAAAAABAAAR4AAAAAAAEQ4AEAAAAAEAABHgAAAAAAARDgAQAAAAAQAAEeAAAAAAABEOABAAAAABAAAR4AAAAAAAEQ4AEAAAAAEAABHgAAAAAAARDgAQAAAAAQAAEeAAAAAAABEOABAAAAABAAAR4AAAAAAAEQ4AEAAAAAEAABHgAAAAAAARDgAQAAAAAQAAEeAAAAAAABEOABAAAAABAAAR4AAAAAAAEQ4AEAAAAAEAABHgAAAAAAARDgAQAAAAAQAAEeAAAAAAABEOABAAAAABAAAR4AAAAAAAEQ4AEAAAAAEAABHgAAAAAAARDgAQAAAAAQAAEeAAAAAAABEOABAAAAABAAAR4AAAAAAAEQ4AEAAAAAEAABHgAAAAAAARDgAQAAAAAQAAEeAAAAAAABEOABAAAAABAAAR4AAAAAAAEQ4AEAAAAAEAABHgAAAAAAAdTydAPgefdtz/Xxv+3pVjjnjycae7oJAAAAAOBWnIEHAAAAAEAABHgAAAAAAARAgAcAAAAAQAAEeAAAAAAABECABwAAAABAAAR4AAAAAAAEQIAHAAAAAEAABHgAAAAAAARAgAcAAAAAQAAEeAAAAAAABECABwAAAABAAAR4AAAAAAAEQIAHAAAAAEAABHgAAAAAAARAgAcAAAAAQAAEeAAAAAAABECABwAAAABAAAR4AAAAAAAEQIAHAAAAAEAABHgAAAAAAARAgAcAAAAAQAAEeAAAAAAABECABwAAAABAAAR4AAAAAAAEQIAHAAAAAEAABHgAAAAAAARAgAcAAAAAQAAEeAAAAAAABECABwAAAABAAAR4AAAAAAAEQIAHAAAAAEAABHgAAAAAAARAgAcAAAAAQAAEeAAAAAAABECABwAAAABAAAR4AAAAAAAEQIAHAAAAAEAABHgAAAAAAARAgAcAAAAAQAAEeAAAAAAABECABwAAAABAAAR4AAAAAAAEQIAHAAAAAEAABHgAAAAAAARAgAcAAAAAQAAEeAAAAAAABECABwAAAABAAAR4AAAAAAAEQIAHAAAAAEAABHgAAAAAAARAgAcAAAAAQAAEeAAAAAAABECABwAAAABAAAR4AAAAAAAEQIAHAAAAAEAABHgAAAD8P/b+PLqO8sAT/h/tsiRL3lfZgFewsYFAIASMDQNZINCQTJJh0gydDifdfQ4zPelOTyYzadKH9KT7HOjuZE73mcxMJsnpzjYhk9AdMnMIizGGsNkwdgze5AV5w6ska7H2+/5Rv9997yvpXksl2fJjfT5/la7q1n3quVX11Pc+VU8BEAEBHgAAACIgwAMAAEAEBHgAAACIgAAPAAAAERDgAQAAIAICPAAAAERAgAcAAIAICPAAAAAQAQEeAAAAIiDAAwAAQAQEeAAAAIiAAA8AAAAREOABAAAgAgI8AAAARECABwAAgAgI8AAAABABAR4AAAAiIMADAABABAR4AAAAiIAADwAAABEQ4AEAACACAjwAAABEQIAHAACACAjwAAAAEAEBHgAAACIgwAMAAEAESse7AOk1NTU9+OCDKd74pS996aabbsp95a/+6q82bNgQQigpKfne975XV1c3NkUEAACAMaIHPnR0dLzyyivJdF9fX5LkidGKFSuKChrR0rZv3/5v/s2/ufzyy6urqxcvXnzPPfc8/fTT56jkAAAAZxVxD/ykSZM+8YlPDH69sbHxjTfeCCEsWrTommuuGTxDfX197p8bN27s7u7O/vnss8/ec889Y11YzrlMJrNv376xWtpjjz32H//jf+zp6Un+3Lt37969e3/xi1/8y3/5L//hH/6huNgvXwAAwPkWcYCvrKwc8hL6F154IQnwy5YtG8419s8++2wIoby8/P3vf//LL7+8f//+vXv3Llq0aMwLzDl18ODBzs7OEMK999576aWXjmZRf/3Xf/3v/t2/CyEsXrz485///GWXXbZ///5vfetbe/fu/eEPf7h06dI/+7M/G4siAwAAjEDEAX5MHDp0aOfOnSGEG2644aMf/ejLL78cQnj22Wc///nPj3fRGJmGhoZk4tFHH121alXq5ezYsSNJ71ddddXzzz8/bdq05PWHH354zZo1mzdv/trXvvb7v//7c+bMGX2ZAQAAhm+iXwmcdL+HEG699daVK1fOmjUrhLBhw4be3t5xLRcjlgT4oqKixYsXj2Y5X/nKV/r6+ioqKp5++ulseg8hTJo06Rvf+EYIob+//x//8R9HWVoAAICRmtABvr+/f/369SGEurq6a665pqioaN26dSGE1tbW119/fZwLxwglAX7evHlVVVWpF3L69OmnnnoqhHD33XfPnj17wH9vvvnmX/7yl0899dSNN944mqICAACkMKED/Jtvvnnq1KkQwi233FJSUhJCuPXWW5N/Pffcc+NZMkYuCfBLly4dzUKef/75rq6uEMJnPvOZIWe4884777rrrtWrV4/mUwAAAFKY0AE+m9KzuX3+/PnLli0LIbz55ptNTU3jVjJGbs+ePSGEJUuWvPDCC/fcc8+iRYsqKysXLFjw6U9/OhnaYDjeeeedZGLlypUhhEwms3Pnzg0bNuzfv//clBoAAGC4Ju4gdtnr5OfPn79kyZLs67feeuuuXbv6+vpeeOGF++67L/Xye3t7k77cC1N/f/94F2FU2tvbB7yS9MD/9Kc//fa3v5198eDBgz/5yU+eeOKJ3/u933v00UfPenV9MqJhCGHy5Mnf/OY3H3/88YMHDyav1NXV3X333X/xF38xderUMVsNYpO743R1dfX19Y1jYSAWuXtKV1eXUWZgOHJ3nM7OzuyjbYECcpuYM2fO5D4s/EJTUVFRWpomjE/cAP/iiy8mh8Js93tizZo13/72t/v6+p599tnRBPi+vr4zZ86MtpTkMaBujx07lkT65ubm+vr6j3zkI6tXr+7u7t62bduPf/zjzs7Ob33rW21tbX/zN39TeLHJZReTJk360pe+9Pd///e5/2ppafn+97//q1/96nvf+9773//+sV4h4tPT0+N0CkbqQj6XgguWHQdSuMB3nJKSknQBfuJeQp+MP58duC6rtrb22muvDSEcOHBg9+7d41I2Rmrfvn3JRPIswL/4i7+4//77H3zwwccee2zDhg3JFRbf//73N27cWHg5HR0dIYQzZ878/d///ZQpU/7yL//y17/+9f79+5999tl/9a/+VQjh2LFjv//7v++nGQAA4PyboAH+3XffTW6ZXrFiRfLouFzZPvnsQ+a4wF155ZWvvPLKK6+88p3vfGfAdfKLFi3667/+62Q69+r6IWUymWSirq5u/fr1n/vc55YuXVpdXX3VVVf91V/91Ve+8pUQQmNj41l78gEAAMbcBL2EPpvMB3S/J66//vrq6ur29vYXX3zxoYceKisrS/ERFRUV5eXloynkORX7LYjTp08f8OfChQvzzfyxj31s9erVW7du3bFjx4A3DpC9v/3RRx+96qqrBvz3T//0T7/73e8eOnTo17/+deHlcLHq6ek5ffp0Ml1dXV1ZWTm+5YEodHd3t7a2JtM1NTUVFRXjWx6IQldXV1tbWzI9efLkC/msEi4cnZ2d2aGyamtr0+W4C9xEDPDJAHXJ9N/93d/93d/9Xb4529vbX3311TVr1qT7oKKionRvPA8u5LINx0jLf8UVV2zdunXfvn0dHR3V1dX5ZpsyZUoyceuttw7+iPLy8muvvfbQoUO/+c1vMplMcfEEvYBlIsvdKoqKimLfj+D8sONACnYcSGEi7DgTMYFs2rSppaVlmDN7IPzFIenwyWQyhceKWL58eTKRr4N95syZIYSOjo7sj+IAAADnx0Tsgc9eP3/77bcneWxIzzzzzIkTJ956662TJ0+6XvoC9/DDD7e0tKxYseLLX/7ykDNs3749hFBfX1/40s33ve99ycTbb789b968fMuZPHlybW3taAsNAAAwEhMuwLe0tGzatCmEUF1d/Qd/8AcF7ovIZDI//vGPM5nM+vXr//k//+fnsYyMWGNj4y9+8YuysrIHH3xwcPDesmXLW2+9FUK46667Ci9n7dq1M2bMOHHixH/7b//tjjvuGPDfHTt2JBvPbbfdNnZlBwAAGJYJdwn9+vXr+/r6Qgg33XRT4VENsuPbuYr+wvfQQw+FEHp6ej796U8PeMbbwYMHP/vZz/b29k6ZMuWrX/1q9vWenp729vb29vaurq7si6WlpX/0R38UQvjpT3/6t3/7t7nLOX78+O/8zu90d3eXlpY+8sgj53Z9AAAABplwAT6bxrPPistn3rx5y5YtCyEcOnRox44d57xkjMI999xz3333hRBeeumlZcuWfe1rX3viiSe++93vfuELX1ixYkXS/f7YY4/NnTs3+5b//J//c01NTU1NzcMPP5y7qD/6oz9Kxp//1//6X99xxx3f+MY3fvKTn3zlK19ZtWrVa6+9FkL4kz/5k+yV9gAAAOfNxLqEvqGh4d133w0hzJo1a8WKFWedf+3atbt27QohPPfcc5dffvk5Lx+j8KMf/eh3f/d3f/jDHx48eHBAD/m0adO++c1v/vZv//ZwllNRUfGLX/ziox/96Ntvv/3ss89mR0wIIZSVlX3lK1/5D//hP4xx0QEAAIZhYvXAZ7vfb7nlluE8VOCWW24pKSkJIWzcuLG7u/vcFo7Rqaio+MEPfvDiiy9+7nOfW7JkSVVVVU1NzcqVK7/whS+8/fbbw0zviQULFmzevPmb3/zmBz/4wenTp5eXly9cuPCBBx7YvHnzI488UngcewAAgHOkKJPJjHcZGAe9vb3XXXfdli1bQgiX/WBXcUXVeJdoZBo+MX+8i8BE1NPTk30IZU1NTWVl5fiWB6LQ3d19+vTpZHry5MmFnwYCJLq6ulpbW5Pp2tra8vLy8S0PRKGzszP7sOe6urrCQ55FamL1wAMAAECkBHgAAACIgAAPAAAAERDgAQAAIAICPAAAAERAgAcAAIAICPAAAAAQAQEeAAAAIiDAAwAAQAQEeAAAAIiAAA8AAAAREOABAAAgAgI8AAAARECABwAAgAgI8AAAABABAR4AAAAiIMADAABABAR4AAAAiIAADwAAABEQ4AEAACACAjwAAABEQIAHAACACAjwAAAAEAEBHgAAACIgwAMAAEAEBHgAAACIgAAPAAAAERDgAQAAIAICPAAAAERAgAcAAIAICPAAAAAQAQEeAAAAIiDAAwAAQAQEeAAAAIiAAA8AAAAREOABAAAgAgI8AAAARECABwAAgAgI8AAAABABAR4AAAAiIMADAABABAR4AAAAiIAADwAAABEQ4AEAACACAjwAAABEQIAHAACACAjwAAAAEAEBHgAAACIgwAMAAEAEBHgAAACIgAAPAAAAERDgAQAAIAICPAAAAERAgAcAAIAICPAAAAAQAQEeAAAAIiDAAwAAQAQEeAAAAIiAAA8AAAAREOABAAAgAgI8AAAARECABwAAgAgI8AAAABABAR4AAAAiIMADAABABAR4AAAAiIAADwAAABEQ4AEAACACAjwAAABEQIAHAACACAjwAAAAEAEBHgAAACIgwAMAAEAEBHgAAACIgAAPAAAAERDgAQAAIAICPAAAAERAgAcAAIAICPAAAAAQAQEeAAAAIiDAAwAAQAQEeAAAAIiAAA8AAAARKB3vAjD+Xv/Q1BkzZox3KQAAAChEDzwAAABEQIAHAACACAjwAAAAEAEBHgAAACIgwAMAAEAEBHgAAACIgAAPAAAAERDgAQAAIAICPAAAAERAgAcAAIAICPAAAAAQAQEeAAAAIiDAAwAAQAQEeAAAAIiAAA8AAAAREOABAAAgAgI8AAAARECABwAAgAgI8AAAABABAR4AAAAiUDreBWD8Xf+rpuKKrvEuRSENn5g/3kUAAAAYZ3rgAQAAIAICPAAAAERAgAcAAIAICPAAAAAQAQEeAAAAIiDAAwAAQAQEeAAAAIiAAA8AAAAREOABAAAgAgI8AAAARECABwAAgAgI8AAAABABAR4AAAAiIMADAABABAR4AAAAiIAADwAAABEQ4AEAACACAjwAAABEQIAHAACACAjwAAAAEAEBHgAAACIgwAMAAEAEBHgAAACIgAAPAAAAERDgAQAAIAICPAAAAERAgAcAAIAICPAAAAAQAQEeAAAAIiDAAwAAQAQEeAAAAIiAAA8AAAAREOABAAAgAgI8AAAARECABwAAgAgI8AAAABABAR4AAAAiIMADAABABAR4AAAAiIAADwAAABEQ4AEAACACAjwAAABEQIAHAACACAjwAAAAEAEBHgAAACIgwAMAAEAEBHgAAACIgAAPAAAAERDgAQAAIAICPAAAAERAgAcAAIAICPAAAAAQAQEeAAAAIiDAAwAAQAQEeAAAAIiAAA8AAAAREOABAAAgAgI8AAAARECABwAAgAgI8AAAABABAR4AAAAiIMADAABABAR4AAAAiIAADwAAABEQ4AEAACACAjwAAABEQIAHAACACAjwAAAAEAEBHgAAACIgwAMAAEAEBHgAAACIgAAPAAAAERDgAQAAIAICPAAAAERAgAcAAIAICPAAAAAQAQEeAAAAIiDAAwAAQAQEeAAAAIiAAA8AAAAREOABAAAgAgI8AAAARECABwAAgAiUjncBzq329vb7778/hDBr1qxvf/vbIYSmpqYHH3wwxaK+9KUv3XTTTWNcPgAAABgePfBEZsWKFUUFjXcBAQAAzomLvAd+sEmTJn3iE58Y/HpjY+Mbb7wRQli0aNE111wzeIb6+vpzXjjOJpPJ7Nu3b7xLAQAAMA4mXICvrKwc8hL6F154IQnwy5YtS3eNPefBwYMHOzs7Qwj33nvvpZdeOt7FAQAAOH8mXIAnag0NDcnEo48+umrVqvEtDAAAwPnkHnhikgT4oqKixYsXj3dZAAAAzisBnpgkAX7evHlVVVXjXRYAAIDzSoAnJkmAX7p06XgXBAAA4HxzD/y5kslk+vr6xrsUeV3IZRust7c3mUgC/KJFi5577rlvfOMb27ZtO3LkyMyZM2+88caHH374gx/84LgWk4tf7o7T39+f3TKBAnJ3nL6+PjsODIcdB1Lo7+/PTvf19V3IT5guLi4uLk7Tmy7Anyvd3d2tra3jXYqLRHNzczKRBPif/exn3/nOd7L/PXjw4BNPPPHTn/70c5/73COPPDJp0qTxKSUTTEdHR0dHx3iXAiJjx4EU2tvbx7sIEJ+2trbxLkIhNTU1lZWVKd4owBONY8eOJad9zc3N9fX1H/nIR1avXt3d3b1t27Yf//jHnZ2d3/72tzs7O//mb/5mvEsKAAAw9gR4orFv375k4qMf/ei3vvWt3HHs/uAP/uAzn/lMQ0PD97///Y9//ONr1qwZpzICAACcKwL8uVJaWlpTUzPepcgr9/6QC19SkzfccMOWLVtCCIsWLSot/f9suqtXr/4v/+W/3HHHHSGE7373ux/96EfHpZxc9Pr6+s6cOZNMV1RUlJWVjW95IAq9vb2dnZ3JdGVl5YADODAkOw6k0NPT09XVlUxPmjSppKRkfMtTQOrTSMeCc6WkpORC3mLiGgoluT+ksrJyxowZ+ea5/fbbV69evXXr1rfffjvd/SRwVj09PdkAX1ZWZkuD4eju7s7mkLKysoqKivEtD0Shq6sru+OUl5eXl5ePb3kgFtkAX15eflH2tXiMHBePK664IoSwb98+Y70AAAAXHwGei0fSq5PJZFxmBgAAXHzkHKLx8MMPt7S0rFix4stf/vKQM2zfvj2EUF9f7/pMAADg4iPAE43GxsZf/OIXZWVlDz744Lx58wb8d8uWLW+99VYI4a677hqP0gEAAJxbLqEnGg899FAIoaen59Of/nR2ILHEwYMHP/vZz/b29k6ZMuWrX/3qOBUQAADgHNIDTzTuueee++677+c///lLL720bNmyz3/+85dffnlbW9vWrVv/x//4H62trSGExx57bO7cueNdUgAAgLEnwBOTH/3oR7/7u7/7wx/+8ODBg4888kjuv6ZNm/bNb37zt3/7t8erbAAAAOeUS+iJSUVFxQ9+8IMXX3zxc5/73JIlS6qqqmpqalauXPmFL3zh7bfflt4BAICL2EXeA19dXf1P//RPw5lz3bp169atO8fFYWysWbNmzZo1410KAACA80oPPAAAAERAgAcAAIAICPAAAAAQAQEeAAAAIiDAAwAAQAQEeAAAAIiAAA8AAAAREOABAAAgAgI8AAAARECABwAAgAgI8AAAABABAR4AAAAiIMADAABABAR4AAAAiIAADwAAABEQ4AEAACACAjwAAABEQIAHAACACAjwAAAAEAEBHgAAACIgwAMAAEAEBHgAAACIgAAPAAAAERDgAQAAIAICPAAAAERAgAcAAIAICPAAAAAQAQEeAAAAIiDAAwAAQAQEeAAAAIiAAA8AAAAREOABAAAgAgI8AAAARECABwAAgAgI8AAAABABAR4AAAAiIMADAABABAR4AAAAiIAADwAAABEQ4AEAACACAjwAAABEQIAHAACACAjwAAAAEAEBHgAAACIgwAMAAEAEBHgAAACIgAAPAAAAERDgAQAAIAICPAAAAERAgAcAAIAICPAAAAAQAQEeAAAAIiDAAwAAQAQEeAAAAIiAAA8AAAAREOABAAAgAgI8AAAARECABwAAgAgI8AAAABABAR4AAAAiIMADAABABAR4AAAAiIAADwAAABEQ4AEAACACAjwAAABEQIAHAACACAjwAAAAEAEBHgAAACIgwAMAAEAEBHgAAACIgAAPAAAAERDgAQAAIAICPAAAAERAgAcAAIAICPAAAAAQAQEeAAAAIiDAAwAAQAQEeAAAAIiAAA8AAAAREOABAAAgAgI8AAAARECABwAAgAiUjncBGH+vf2jqjBkzxrsUAAAAFKIHHgAAACIgwAMAAEAEBHgAAACIgAAPAAAAERDgAQAAIAICPAAAAERAgAcAAIAICPAAAAAQAQEeAAAAIiDAAwAAQAQEeAAAAIiAAA8AAAAREOABAAAgAgI8AAAARECABwAAgAgI8AAAABABAR4AAAAiIMADAABABAR4AAAAiIAADwAAABEQ4AEAACACAjwAAABEQIAHAACACAjwAAAAEAEBHgAAACIgwAMAAEAEBHgAAACIgAAPAAAAERDgAQAAIAICPAAAAESgdLwLwPgoKipavnx5UVFRCKG01GYAw1JUVJTdX4qL/QAKw2LHgRTsOJBCcXFxdsdJks7FpyiTyYx3GQAAAICz8HseAAAARECABwAAgAgI8AAAABABAR4AAAAiIMADAABABAR4AAAAiIAADwAAABEQ4AEAACACAjwAAABEQIAHAACACAjwAAAAEAEBHgAAACIgwAMAAEAEBHgAAACIgAAPAAAAERDgAQAAIAKl410AzrdMJrN+/foNGzbs37+/tbW1trb20ksvXbdu3dq1a4uKisa7dDA+uru7t2zZ8uabb+7evfvIkSMdHR2TJk2aPXv2ihUrPvShD11yySX53vjFL35x165dBZa8bNmyxx9//BwUGcbfKLd/7RETzXe+850nn3xyOHN+9rOfve+++3Jf0dxw0evr62tsbGxoaNi9e3dDQ8P+/ft7e3tDCA899NA999xz1renblOia4wE+Imlubn561//+o4dO7KvnDp16tSpU2+++ebTTz/95S9/uba2dhyLB+Pin/7pn370ox+1t7fnvtjW1tbW1rZnz56nnnrqzjvvfOihh0pKSsarhHDx0R5BAdOmTRvvIsD59p/+03/atGlTuvemblNibIwE+Amku7v70UcfbWhoCCFMmzbttttumzlz5rFjx55//vmmpqa33377z//8z7/+9a+XltoqmFjeeeedJL2XlJQsXrz40ksvrampaW1t3bp169GjRzOZzC9/+cu2trY//uM/zreE8vLyu+++e8h/zZw581yVGy4MKbZ/7RET0+rVqwv8FtzS0vLss8+GECZNmvSBD3xgyHk0N1zE+vv7s9NTpkwpLy8/duzYcN6Yuk2JtDG6sErDOfXkk08mG+iyZcv+7M/+rKamJnn94x//+Fe/+tWGhoYdO3Y89dRT995777gWE8bBggUL7rrrrltuuSW7X4QQMpnMk08++b3vfS+TyWzYsGHt2rXXXXfdkG+vqKh48MEHz1dh4cKSYvvXHjExXXfddfl8ezQ5AAAgAElEQVTakRDC//pf/yuZWLNmTUVFxZDzaG64iC1fvnzx4sVLlixZunTpjBkz/uf//J8/+MEPhvPG1G1KpI2RQewmiu7u7p/97GchhJKSki9+8Yu5KWXy5Mlf/OIXk5+En3jiieRuE5g47r///r/927+98847c/eLEEJRUdF99933sY99LPlz/fr141E6uNhoj2BISfd7COH2228f35LAuLj//vsfeOCBG2+8ccaMGcN/V+o2Jd7GSICfKN56662Ojo4Qwgc+8IE5c+YM+O+8efOSn4RbW1u3bNkyDuWD8XPJJZcUGKTkjjvuSCYaGxvPV4ngYqY9gsG2b99+6NChEEJ9ff3ll18+3sWBaKRuU+JtjAT4ieKtt95KJq699tohZ8i+/uabb56nMkEM6urqkomenp7xLQlcHLRHMNgzzzyTTOh+hxFJ3abE2xi5B36iePfdd5OJpUuXDjnDsmXLkgndjJDr4MGDycTs2bPzzdPV1fXoo4/u3r27ra2tqqpq9uzZq1at+vCHPzxv3rzzVUwYNyPd/rVHMEBnZ+fLL78cQigpKbn11lsLzKm5gQFStynxNkYC/ERx+PDhZCJfCMkOXpqdEwg5vSLvf//7883T3d2dffBJa2tra2trQ0PDk08+ed999z3wwAOeP8fFbaTbv/YIBnj55ZfPnDkTQrj22munTp1aYE7NDQyQuk2JtzES4CeK5ClZZWVllZWVQ84wefLkoqKiTCYz4GnYMJFt2bJlw4YNIYRp06Zlb4Yf7JJLLlm0aNGUKVP6+/uPHTu2devW9vb2TCbzs5/97OTJkwWePwcXgZFu/9ojGGD4w9dpbmCA1G1KvI2RAD8hZDKZ7u7uEEJZWVmB2crLy7u6ujo7O89XueCCdvTo0ccffzyTyRQVFT388MNDPtTn7rvvXrly5YDhUjs7O5944omf/vSnyfPnrr766n/2z/7Z+So1nD8ptn/tEQxw5MiRt99+O4RQV1dX4FIvzQ0MlrpNiboxMojdhJDJZJKJAkNtA7lOnz796KOPtrS0hBA+9alP5Xty79q1awc/7KSysvKBBx74F//iXyR//uQnPzmnRYXxkmL71x7BANkbtW699dYC18BrbmCw1G1K1I2RAD8hFBcXl5eXhxCSn5rySf6b7zISmDja2toeeeSRAwcOhBDuvPPOz3zmMykW8slPfjIZwf7IkSPJw4Fg4si3/WuPIFcmk1m/fn0ynXr8ec0NE1bqNiXqxkiAnyiqq6tDCD09PfkuAmltbU1+i0rmhAmrvb39kUce2bt3bwjhjjvu+L3f+710yyktLb3yyiuTaWdUTDQFtn/tEWS9+eabJ0+eDCEsXbp04cKF6RaiuWEiS92mxNsYCfATRfb5IkePHh1yhuPHjw+YEyag9vb2P/3TP21oaAgh3HbbbQ8//PBorq2qra1NJtra2samfBCPfNu/9giyhj98XWGaGyas1G1KvI2RAD9RXHLJJcnE7t27h5xh165dA+aEiSY3va9bt+4P//APR3ln1OnTp5OJmpqaMSgfRCXf9q89gkRra+trr70WQigvL1+7du1oFqW5YcJK3abE2xgJ8BPF+973vmRi8+bNQ86QfT07J0wouel9zZo1//bf/ttRpvfe3t5t27Yl0xfab7dwrhXY/rVHkHjhhRd6e3tDCDfeeGNVVVXq5WhumMhStynxNkYC/ERx9dVXJ23Dq6+++t577w347+HDhzdt2hRCmDx58lVXXTUO5YNxlZveb7rppj/+4z8uLh7t4fGJJ55IBrGfPXt2fX39GJQS4lFg+9ceQWKsrp/X3DCRpW5T4m2MBPiJory8/OMf/3gIoa+v7/HHH29vb8/+q7W19fHHH+/r6wshfPKTnyzwCBO4KHV0dDzyyCNJer/xxhu/+MUvDjO9f+c733n66adz96ZEZ2fnP/zDP/z4xz9O/vzkJz85tgWGC0Hq7V97BCGEPXv27Nu3L4Qwa9as1atXF55ZcwP5pG5T4m2MirIPweOi193d/e///b9PUsq0adNuu+22WbNmHTt27LnnnmtqagohXH755V//+tdLS0vHu6RwXv35n//566+/HkIoLy//2Mc+VmAX+MxnPpN7Xf2jjz66adOmkpKSxYsX19fXT548ub+//+jRo9u2bevo6Ejmufnmm//kT/4kxqeMQmGj2f61R/Bf/+t//eUvfxlCuP/++++///7CM2tumAgOHTqUfapiCOGdd95J7g25+uqrly1bln39wx/+8MyZM3PfmLpNibQxEuAnlubm5q9//es7duwY/K+VK1d++ctfzo5iChPHH/7hHybdIGf185//PPdX2OSMKt/MxcXF99577wMPPHCh/XALY2KU27/2iImsp6fnd37nd1pbW4uKiv77f//vs2bNKjy/5oaJ4I033vja17521tn+8i//csWKFQNeTN2mxNgYCfATTiaTWb9+/YYNG/bv39/a2jp58uTLLrts3bp1a9eu9astE1PqAN/U1LRt27Zt27bt2bOnubm5paWlv7+/urp6wYIFK1euvP322896TgbxGv32rz1iwtq4ceNjjz0WQrjqqquGk1g0N0wEownwYRRtSnSNkQAPAAAAETCIHQAAAERAgAcAAIAICPAAAAAQAQEeAAAAIiDAAwAAQAQEeAAAAIiAAA8AAAAREOABAAAgAgI8AAAARECABwAAgAgI8AAAABABAR4AAAAiIMADAABABAR4AAAAiIAADwAAABEQ4AEAACACAjwAAABEQIAHAACACAjwAAAAEAEBHgAAACIgwAMAAEAEBHgAAACIgAAPAAAAERDgAQAAIAICPAAAAERAgAcAAIAICPAAAAAQAQEeAAAAIiDAAwAAQAQEeAAAAIiAAA8AAAAREOABAAAgAgI8AAAARECABwAAgAgI8AAAABABAR4AAAAiIMADAABABAR4AAAAiIAADwAAABEQ4AEAACACAjwAAABEQIAHAACACAjwAAAAEAEBHgAAACIgwAMAAEAEBHgAAACIgAAPAAAAERDgAQAAIAICPAAAAERAgAcAAIAICPAAAAAQAQEeAAAAIiDAAwAAQAQEeAAAAIiAAA8AAAAREOABAAAgAgI8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" width="672" /></p>
</div>
<div id="subndice-transparencia-activa" class="section level2 unnumbered">
<h2>Subndice Transparencia Activa</h2>
<p>Se releva una seleccin de los tipos de informacin exigibles en los trminos del artculo 32 de la Ley 27.275. Una vez obtenido el valor de cada uno de los tems, se realiza una suma ponderada para calcular el valor del desempeo de la transparencia activa de los sujetos obligados. De esta manera, al multiplicar y sumar los valores de cada tem por su ponderador, el resultado dar un valor entre 0 y 100</p>
<div id="rinbwabjax" style="padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;">
<style>#rinbwabjax table {
font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
-webkit-font-smoothing: antialiased;
-moz-osx-font-smoothing: grayscale;
}
#rinbwabjax thead, #rinbwabjax tbody, #rinbwabjax tfoot, #rinbwabjax tr, #rinbwabjax td, #rinbwabjax th {
border-style: none;
}
#rinbwabjax p {
margin: 0;
padding: 0;
}
#rinbwabjax .gt_table {
display: table;
border-collapse: collapse;
line-height: normal;
margin-left: auto;
margin-right: auto;
color: #333333;
font-size: 16px;
font-weight: normal;
font-style: normal;
background-color: #FFFFFF;
width: 95%;
border-top-style: solid;
border-top-width: 2px;
border-top-color: #A8A8A8;
border-right-style: none;
border-right-width: 2px;
border-right-color: #D3D3D3;
border-bottom-style: solid;
border-bottom-width: 2px;
border-bottom-color: #A8A8A8;
border-left-style: none;
border-left-width: 2px;
border-left-color: #D3D3D3;
}
#rinbwabjax .gt_caption {
padding-top: 4px;
padding-bottom: 4px;
}
#rinbwabjax .gt_title {
color: #333333;
font-size: 125%;
font-weight: initial;
padding-top: 4px;
padding-bottom: 4px;
padding-left: 5px;
padding-right: 5px;
border-bottom-color: #FFFFFF;
border-bottom-width: 0;
}
#rinbwabjax .gt_subtitle {
color: #333333;
font-size: 85%;
font-weight: initial;
padding-top: 3px;
padding-bottom: 5px;
padding-left: 5px;
padding-right: 5px;
border-top-color: #FFFFFF;
border-top-width: 0;
}
#rinbwabjax .gt_heading {
background-color: #FFFFFF;
text-align: center;
border-bottom-color: #FFFFFF;
border-left-style: none;
border-left-width: 1px;
border-left-color: #D3D3D3;
border-right-style: none;
border-right-width: 1px;
border-right-color: #D3D3D3;
}
#rinbwabjax .gt_bottom_border {
border-bottom-style: solid;
border-bottom-width: 2px;
border-bottom-color: #D3D3D3;
}
#rinbwabjax .gt_col_headings {
border-top-style: solid;
border-top-width: 2px;
border-top-color: #D3D3D3;
border-bottom-style: solid;
border-bottom-width: 2px;
border-bottom-color: #D3D3D3;
border-left-style: none;
border-left-width: 1px;
border-left-color: #D3D3D3;
border-right-style: none;
border-right-width: 1px;
border-right-color: #D3D3D3;
}
#rinbwabjax .gt_col_heading {
color: #333333;
background-color: #FFFFFF;
font-size: 100%;
font-weight: normal;
text-transform: inherit;
border-left-style: none;
border-left-width: 1px;
border-left-color: #D3D3D3;
border-right-style: none;
border-right-width: 1px;
border-right-color: #D3D3D3;
vertical-align: bottom;
padding-top: 5px;
padding-bottom: 6px;
padding-left: 5px;
padding-right: 5px;
overflow-x: hidden;
}
#rinbwabjax .gt_column_spanner_outer {
color: #333333;
background-color: #FFFFFF;
font-size: 100%;
font-weight: normal;
text-transform: inherit;
padding-top: 0;
padding-bottom: 0;
padding-left: 4px;
padding-right: 4px;
}
#rinbwabjax .gt_column_spanner_outer:first-child {
padding-left: 0;
}
#rinbwabjax .gt_column_spanner_outer:last-child {
padding-right: 0;
}
#rinbwabjax .gt_column_spanner {
border-bottom-style: solid;
border-bottom-width: 2px;
border-bottom-color: #D3D3D3;
vertical-align: bottom;
padding-top: 5px;
padding-bottom: 5px;
overflow-x: hidden;
display: inline-block;
width: 100%;
}
#rinbwabjax .gt_spanner_row {
border-bottom-style: hidden;
}
#rinbwabjax .gt_group_heading {
padding-top: 8px;
padding-bottom: 8px;
padding-left: 5px;
padding-right: 5px;
color: #333333;
background-color: #FFFFFF;
font-size: 100%;
font-weight: initial;
text-transform: inherit;
border-top-style: solid;
border-top-width: 2px;
border-top-color: #D3D3D3;
border-bottom-style: solid;
border-bottom-width: 2px;
border-bottom-color: #D3D3D3;
border-left-style: none;
border-left-width: 1px;
border-left-color: #D3D3D3;
border-right-style: none;
border-right-width: 1px;
border-right-color: #D3D3D3;
vertical-align: middle;
text-align: left;
}
#rinbwabjax .gt_empty_group_heading {
padding: 0.5px;
color: #333333;
background-color: #FFFFFF;
font-size: 100%;
font-weight: initial;
border-top-style: solid;
border-top-width: 2px;
border-top-color: #D3D3D3;
border-bottom-style: solid;
border-bottom-width: 2px;
border-bottom-color: #D3D3D3;
vertical-align: middle;
}
#rinbwabjax .gt_from_md > :first-child {
margin-top: 0;
}
#rinbwabjax .gt_from_md > :last-child {
margin-bottom: 0;
}
#rinbwabjax .gt_row {
padding-top: 8px;
padding-bottom: 8px;
padding-left: 5px;
padding-right: 5px;
margin: 10px;
border-top-style: solid;
border-top-width: 1px;
border-top-color: #D3D3D3;
border-left-style: none;
border-left-width: 1px;
border-left-color: #D3D3D3;
border-right-style: none;
border-right-width: 1px;
border-right-color: #D3D3D3;
vertical-align: middle;
overflow-x: hidden;
}
#rinbwabjax .gt_stub {
color: #333333;
background-color: #FFFFFF;
font-size: 100%;
font-weight: initial;
text-transform: inherit;
border-right-style: solid;
border-right-width: 2px;
border-right-color: #D3D3D3;
padding-left: 5px;
padding-right: 5px;
}
#rinbwabjax .gt_stub_row_group {
color: #333333;
background-color: #FFFFFF;
font-size: 100%;
font-weight: initial;
text-transform: inherit;
border-right-style: solid;
border-right-width: 2px;
border-right-color: #D3D3D3;
padding-left: 5px;
padding-right: 5px;
vertical-align: top;
}
#rinbwabjax .gt_row_group_first td {
border-top-width: 2px;
}
#rinbwabjax .gt_row_group_first th {
border-top-width: 2px;
}
#rinbwabjax .gt_summary_row {
color: #333333;
background-color: #FFFFFF;
text-transform: inherit;
padding-top: 8px;
padding-bottom: 8px;
padding-left: 5px;
padding-right: 5px;
}
#rinbwabjax .gt_first_summary_row {
border-top-style: solid;
border-top-color: #D3D3D3;
}
#rinbwabjax .gt_first_summary_row.thick {
border-top-width: 2px;
}
#rinbwabjax .gt_last_summary_row {
padding-top: 8px;
padding-bottom: 8px;
padding-left: 5px;
padding-right: 5px;
border-bottom-style: solid;
border-bottom-width: 2px;
border-bottom-color: #D3D3D3;
}
#rinbwabjax .gt_grand_summary_row {
color: #333333;
background-color: #FFFFFF;
text-transform: inherit;
padding-top: 8px;
padding-bottom: 8px;
padding-left: 5px;
padding-right: 5px;
}
#rinbwabjax .gt_first_grand_summary_row {
padding-top: 8px;
padding-bottom: 8px;
padding-left: 5px;
padding-right: 5px;
border-top-style: double;
border-top-width: 6px;
border-top-color: #D3D3D3;
}
#rinbwabjax .gt_last_grand_summary_row_top {
padding-top: 8px;
padding-bottom: 8px;
padding-left: 5px;
padding-right: 5px;
border-bottom-style: double;
border-bottom-width: 6px;
border-bottom-color: #D3D3D3;
}
#rinbwabjax .gt_striped {
background-color: rgba(128, 128, 128, 0.05);
}
#rinbwabjax .gt_table_body {
border-top-style: solid;
border-top-width: 2px;
border-top-color: #D3D3D3;
border-bottom-style: solid;
border-bottom-width: 2px;
border-bottom-color: #D3D3D3;
}
#rinbwabjax .gt_footnotes {
color: #333333;
background-color: #FFFFFF;
border-bottom-style: none;
border-bottom-width: 2px;
border-bottom-color: #D3D3D3;
border-left-style: none;
border-left-width: 2px;
border-left-color: #D3D3D3;
border-right-style: none;
border-right-width: 2px;
border-right-color: #D3D3D3;
}
#rinbwabjax .gt_footnote {
margin: 0px;
font-size: 90%;
padding-top: 4px;
padding-bottom: 4px;
padding-left: 5px;
padding-right: 5px;
}
#rinbwabjax .gt_sourcenotes {
color: #333333;
background-color: #FFFFFF;
border-bottom-style: none;
border-bottom-width: 2px;
border-bottom-color: #D3D3D3;
border-left-style: none;
border-left-width: 2px;
border-left-color: #D3D3D3;
border-right-style: none;
border-right-width: 2px;
border-right-color: #D3D3D3;
}
#rinbwabjax .gt_sourcenote {
font-size: 90%;
padding-top: 4px;
padding-bottom: 4px;
padding-left: 5px;
padding-right: 5px;
}
#rinbwabjax .gt_left {
text-align: left;
}
#rinbwabjax .gt_center {
text-align: center;
}
#rinbwabjax .gt_right {
text-align: right;
font-variant-numeric: tabular-nums;
}
#rinbwabjax .gt_font_normal {
font-weight: normal;
}
#rinbwabjax .gt_font_bold {
font-weight: bold;
}
#rinbwabjax .gt_font_italic {
font-style: italic;
}
#rinbwabjax .gt_super {
font-size: 65%;
}
#rinbwabjax .gt_footnote_marks {
font-size: 75%;
vertical-align: 0.4em;
position: initial;
}
#rinbwabjax .gt_asterisk {
font-size: 100%;
vertical-align: 0;
}
#rinbwabjax .gt_indent_1 {
text-indent: 5px;
}
#rinbwabjax .gt_indent_2 {
text-indent: 10px;
}
#rinbwabjax .gt_indent_3 {
text-indent: 15px;
}
#rinbwabjax .gt_indent_4 {
text-indent: 20px;
}
#rinbwabjax .gt_indent_5 {
text-indent: 25px;
}
</style>
<table class="gt_table" data-quarto-disable-processing="false" data-quarto-bootstrap="false">
  <thead>
    <tr class="gt_heading">
      <td colspan="2" class="gt_heading gt_title gt_font_normal" style><strong>Resultados Subndice Transparencia Activa por dimensin</strong></td>
    </tr>
    <tr class="gt_heading">
      <td colspan="2" class="gt_heading gt_subtitle gt_font_normal gt_bottom_border" style>Agencia Federal de Inteligencia - 2 Trimestre 2024 (Abril - Junio)</td>
    </tr>
    <tr class="gt_col_headings">
      <th class="gt_col_heading gt_columns_bottom_border gt_left" rowspan="1" colspan="1" scope="col" id="&lt;strong&gt;Dimensin&lt;/strong&gt;"><strong>Dimensin</strong></th>
      <th class="gt_col_heading gt_columns_bottom_border gt_center" rowspan="1" colspan="1" scope="col" id="&lt;strong&gt;Valor del ndice&lt;/strong&gt;"><strong>Valor del ndice</strong></th>
    </tr>
  </thead>
  <tbody class="gt_table_body">
    <tr><td headers="dimension" class="gt_row gt_left" style="font-weight: bold;">ndice de Transparencia Activa</td>
<td headers="valor" class="gt_row gt_center" style="font-weight: bold;">5,6</td></tr>
    <tr><td headers="dimension" class="gt_row gt_left">1. Misin y/u Objetivos</td>
<td headers="valor" class="gt_row gt_center">66,7</td></tr>
    <tr><td headers="dimension" class="gt_row gt_left">2. Servicios y trmites con requisitos o procedimientos</td>
<td headers="valor" class="gt_row gt_center">0</td></tr>
    <tr><td headers="dimension" class="gt_row gt_left">3. Autoridades y sus designaciones</td>
<td headers="valor" class="gt_row gt_center">0</td></tr>
    <tr><td headers="dimension" class="gt_row gt_left">4. Planilla de personal y organigrama</td>
<td headers="valor" class="gt_row gt_center">0</td></tr>
    <tr><td headers="dimension" class="gt_row gt_left">5. Declaraciones Juradas</td>
<td headers="valor" class="gt_row gt_center">0</td></tr>
    <tr><td headers="dimension" class="gt_row gt_left">6. Escalas Salariales</td>
<td headers="valor" class="gt_row gt_center">0</td></tr>
    <tr><td headers="dimension" class="gt_row gt_left">7. Presupuesto</td>
<td headers="valor" class="gt_row gt_center">0</td></tr>
    <tr><td headers="dimension" class="gt_row gt_left">8. Transferencias</td>
<td headers="valor" class="gt_row gt_center">0</td></tr>
    <tr><td headers="dimension" class="gt_row gt_left">9. Compras y contrataciones</td>
<td headers="valor" class="gt_row gt_center">0</td></tr>
    <tr><td headers="dimension" class="gt_row gt_left">10. Informes de auditora y evaluaciones</td>
<td headers="valor" class="gt_row gt_center">0</td></tr>
    <tr><td headers="dimension" class="gt_row gt_left">11. Solicitud de Informacin</td>
<td headers="valor" class="gt_row gt_center">0</td></tr>
    <tr><td headers="dimension" class="gt_row gt_left">12. Datos del rea encargada y del Responsable de Polticas de Transparencia</td>
<td headers="valor" class="gt_row gt_center">0</td></tr>
    <tr><td headers="dimension" class="gt_row gt_left">13. Participacin ciudadana</td>
<td headers="valor" class="gt_row gt_center">0</td></tr>
  </tbody>
  
  <tfoot class="gt_footnotes">
    <tr>
      <td class="gt_footnote" colspan="2"> Fuente: elaboracin propia en base a resultados IT</td>
    </tr>
  </tfoot>
</table>
</div>
</div>
<div id="subndice-transparencia-proactiva" class="section level2 unnumbered">
<h2>Subndice Transparencia Proactiva</h2>
<p>Los tems de transparencia proactiva son una innovacin en el ndice, dado que amplan las obligaciones de transparencia establecidas en el inciso t del artculo 32 de la Ley 27.275. La contribucin del desempeo de esta seccin tiene un aporte menor al valor del ndice, ya que es de un 10%.</p>
<div id="urufcvhjob" style="padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;">
<style>#urufcvhjob table {
font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
-webkit-font-smoothing: antialiased;
-moz-osx-font-smoothing: grayscale;
}
#urufcvhjob thead, #urufcvhjob tbody, #urufcvhjob tfoot, #urufcvhjob tr, #urufcvhjob td, #urufcvhjob th {
border-style: none;
}
#urufcvhjob p {
margin: 0;
padding: 0;
}
#urufcvhjob .gt_table {
display: table;
border-collapse: collapse;
line-height: normal;
margin-left: auto;
margin-right: auto;
color: #333333;
font-size: 16px;
font-weight: normal;
font-style: normal;
background-color: #FFFFFF;
width: 95%;
border-top-style: solid;
border-top-width: 2px;
border-top-color: #A8A8A8;
border-right-style: none;
border-right-width: 2px;
border-right-color: #D3D3D3;
border-bottom-style: solid;
border-bottom-width: 2px;
border-bottom-color: #A8A8A8;
border-left-style: none;
border-left-width: 2px;
border-left-color: #D3D3D3;
}
#urufcvhjob .gt_caption {
padding-top: 4px;
padding-bottom: 4px;
}
#urufcvhjob .gt_title {
color: #333333;
font-size: 125%;
font-weight: initial;
padding-top: 4px;
padding-bottom: 4px;
padding-left: 5px;
padding-right: 5px;
border-bottom-color: #FFFFFF;
border-bottom-width: 0;
}
#urufcvhjob .gt_subtitle {
color: #333333;
font-size: 85%;
font-weight: initial;
padding-top: 3px;
padding-bottom: 5px;
padding-left: 5px;
padding-right: 5px;
border-top-color: #FFFFFF;
border-top-width: 0;
}
#urufcvhjob .gt_heading {
background-color: #FFFFFF;
text-align: center;
border-bottom-color: #FFFFFF;
border-left-style: none;
border-left-width: 1px;
border-left-color: #D3D3D3;
border-right-style: none;
border-right-width: 1px;
border-right-color: #D3D3D3;
}
#urufcvhjob .gt_bottom_border {
border-bottom-style: solid;
border-bottom-width: 2px;
border-bottom-color: #D3D3D3;
}
#urufcvhjob .gt_col_headings {
border-top-style: solid;
border-top-width: 2px;
border-top-color: #D3D3D3;
border-bottom-style: solid;
border-bottom-width: 2px;
border-bottom-color: #D3D3D3;
border-left-style: none;
border-left-width: 1px;
border-left-color: #D3D3D3;
border-right-style: none;
border-right-width: 1px;
border-right-color: #D3D3D3;
}
#urufcvhjob .gt_col_heading {
color: #333333;
background-color: #FFFFFF;
font-size: 100%;
font-weight: normal;
text-transform: inherit;
border-left-style: none;
border-left-width: 1px;
border-left-color: #D3D3D3;
border-right-style: none;
border-right-width: 1px;
border-right-color: #D3D3D3;
vertical-align: bottom;
padding-top: 5px;
padding-bottom: 6px;
padding-left: 5px;
padding-right: 5px;
overflow-x: hidden;
}
#urufcvhjob .gt_column_spanner_outer {
color: #333333;
background-color: #FFFFFF;
font-size: 100%;
font-weight: normal;
text-transform: inherit;
padding-top: 0;
padding-bottom: 0;
padding-left: 4px;
padding-right: 4px;
}
#urufcvhjob .gt_column_spanner_outer:first-child {
padding-left: 0;
}
#urufcvhjob .gt_column_spanner_outer:last-child {
padding-right: 0;
}
#urufcvhjob .gt_column_spanner {
border-bottom-style: solid;
border-bottom-width: 2px;
border-bottom-color: #D3D3D3;
vertical-align: bottom;
padding-top: 5px;
padding-bottom: 5px;
overflow-x: hidden;
display: inline-block;
width: 100%;
}
#urufcvhjob .gt_spanner_row {
border-bottom-style: hidden;
}
#urufcvhjob .gt_group_heading {
padding-top: 8px;
padding-bottom: 8px;
padding-left: 5px;
padding-right: 5px;
color: #333333;
background-color: #FFFFFF;
font-size: 100%;
font-weight: initial;
text-transform: inherit;
border-top-style: solid;
border-top-width: 2px;
border-top-color: #D3D3D3;
border-bottom-style: solid;
border-bottom-width: 2px;
border-bottom-color: #D3D3D3;
border-left-style: none;
border-left-width: 1px;
border-left-color: #D3D3D3;
border-right-style: none;
border-right-width: 1px;
border-right-color: #D3D3D3;
vertical-align: middle;
text-align: left;
}
#urufcvhjob .gt_empty_group_heading {
padding: 0.5px;
color: #333333;
background-color: #FFFFFF;
font-size: 100%;
font-weight: initial;
border-top-style: solid;
border-top-width: 2px;
border-top-color: #D3D3D3;
border-bottom-style: solid;
border-bottom-width: 2px;
border-bottom-color: #D3D3D3;
vertical-align: middle;
}
#urufcvhjob .gt_from_md > :first-child {
margin-top: 0;
}
#urufcvhjob .gt_from_md > :last-child {
margin-bottom: 0;
}
#urufcvhjob .gt_row {
padding-top: 8px;
padding-bottom: 8px;
padding-left: 5px;
padding-right: 5px;
margin: 10px;
border-top-style: solid;
border-top-width: 1px;
border-top-color: #D3D3D3;
border-left-style: none;
border-left-width: 1px;
border-left-color: #D3D3D3;
border-right-style: none;
border-right-width: 1px;
border-right-color: #D3D3D3;
vertical-align: middle;
overflow-x: hidden;
}
#urufcvhjob .gt_stub {
color: #333333;
background-color: #FFFFFF;
font-size: 100%;
font-weight: initial;
text-transform: inherit;
border-right-style: solid;
border-right-width: 2px;
border-right-color: #D3D3D3;
padding-left: 5px;
padding-right: 5px;
}
#urufcvhjob .gt_stub_row_group {
color: #333333;
background-color: #FFFFFF;
font-size: 100%;
font-weight: initial;
text-transform: inherit;
border-right-style: solid;
border-right-width: 2px;
border-right-color: #D3D3D3;
padding-left: 5px;
padding-right: 5px;
vertical-align: top;
}
#urufcvhjob .gt_row_group_first td {
border-top-width: 2px;
}
#urufcvhjob .gt_row_group_first th {
border-top-width: 2px;
}
#urufcvhjob .gt_summary_row {
color: #333333;
background-color: #FFFFFF;
text-transform: inherit;
padding-top: 8px;
padding-bottom: 8px;
padding-left: 5px;
padding-right: 5px;
}
#urufcvhjob .gt_first_summary_row {
border-top-style: solid;
border-top-color: #D3D3D3;
}
#urufcvhjob .gt_first_summary_row.thick {
border-top-width: 2px;
}
#urufcvhjob .gt_last_summary_row {
padding-top: 8px;
padding-bottom: 8px;
padding-left: 5px;
padding-right: 5px;
border-bottom-style: solid;
border-bottom-width: 2px;
border-bottom-color: #D3D3D3;
}
#urufcvhjob .gt_grand_summary_row {
color: #333333;
background-color: #FFFFFF;
text-transform: inherit;
padding-top: 8px;
padding-bottom: 8px;
padding-left: 5px;
padding-right: 5px;
}
#urufcvhjob .gt_first_grand_summary_row {
padding-top: 8px;
padding-bottom: 8px;
padding-left: 5px;
padding-right: 5px;
border-top-style: double;
border-top-width: 6px;
border-top-color: #D3D3D3;
}
#urufcvhjob .gt_last_grand_summary_row_top {
padding-top: 8px;
padding-bottom: 8px;
padding-left: 5px;
padding-right: 5px;
border-bottom-style: double;
border-bottom-width: 6px;
border-bottom-color: #D3D3D3;
}
#urufcvhjob .gt_striped {
background-color: rgba(128, 128, 128, 0.05);
}
#urufcvhjob .gt_table_body {
border-top-style: solid;
border-top-width: 2px;
border-top-color: #D3D3D3;
border-bottom-style: solid;
border-bottom-width: 2px;
border-bottom-color: #D3D3D3;
}
#urufcvhjob .gt_footnotes {
color: #333333;
background-color: #FFFFFF;
border-bottom-style: none;
border-bottom-width: 2px;
border-bottom-color: #D3D3D3;
border-left-style: none;
border-left-width: 2px;
border-left-color: #D3D3D3;
border-right-style: none;
border-right-width: 2px;
border-right-color: #D3D3D3;
}
#urufcvhjob .gt_footnote {
margin: 0px;
font-size: 90%;
padding-top: 4px;
padding-bottom: 4px;
padding-left: 5px;
padding-right: 5px;
}
#urufcvhjob .gt_sourcenotes {
color: #333333;
background-color: #FFFFFF;
border-bottom-style: none;
border-bottom-width: 2px;
border-bottom-color: #D3D3D3;
border-left-style: none;
border-left-width: 2px;
border-left-color: #D3D3D3;
border-right-style: none;
border-right-width: 2px;
border-right-color: #D3D3D3;
}
#urufcvhjob .gt_sourcenote {
font-size: 90%;
padding-top: 4px;
padding-bottom: 4px;
padding-left: 5px;
padding-right: 5px;
}
#urufcvhjob .gt_left {
text-align: left;
}
#urufcvhjob .gt_center {
text-align: center;
}
#urufcvhjob .gt_right {
text-align: right;
font-variant-numeric: tabular-nums;
}
#urufcvhjob .gt_font_normal {
font-weight: normal;
}
#urufcvhjob .gt_font_bold {
font-weight: bold;
}
#urufcvhjob .gt_font_italic {
font-style: italic;
}
#urufcvhjob .gt_super {
font-size: 65%;
}
#urufcvhjob .gt_footnote_marks {
font-size: 75%;
vertical-align: 0.4em;
position: initial;
}
#urufcvhjob .gt_asterisk {
font-size: 100%;
vertical-align: 0;
}
#urufcvhjob .gt_indent_1 {
text-indent: 5px;
}
#urufcvhjob .gt_indent_2 {
text-indent: 10px;
}
#urufcvhjob .gt_indent_3 {
text-indent: 15px;
}
#urufcvhjob .gt_indent_4 {
text-indent: 20px;
}
#urufcvhjob .gt_indent_5 {
text-indent: 25px;
}
</style>
<table class="gt_table" data-quarto-disable-processing="false" data-quarto-bootstrap="false">
  <thead>
    <tr class="gt_heading">
      <td colspan="2" class="gt_heading gt_title gt_font_normal" style><strong>ndice de Transparencia segn dimensin</strong></td>
    </tr>
    <tr class="gt_heading">
      <td colspan="2" class="gt_heading gt_subtitle gt_font_normal gt_bottom_border" style>Agencia Federal de Inteligencia - 2 Trimestre 2024 (Abril - Junio)</td>
    </tr>
    <tr class="gt_col_headings">
      <th class="gt_col_heading gt_columns_bottom_border gt_left" rowspan="1" colspan="1" scope="col" id="&lt;strong&gt;Dimensin&lt;/strong&gt;"><strong>Dimensin</strong></th>
      <th class="gt_col_heading gt_columns_bottom_border gt_center" rowspan="1" colspan="1" scope="col" id="&lt;strong&gt;Valor del ndice&lt;/strong&gt;"><strong>Valor del ndice</strong></th>
    </tr>
  </thead>
  <tbody class="gt_table_body">
    <tr><td headers="dimension" class="gt_row gt_left">ndice de Transparencia Proactiva</td>
<td headers="valor" class="gt_row gt_center">0</td></tr>
    <tr><td headers="dimension" class="gt_row gt_left">14. Dotacin ptima</td>
<td headers="valor" class="gt_row gt_center">0</td></tr>
    <tr><td headers="dimension" class="gt_row gt_left">15. Polticas de Integridad</td>
<td headers="valor" class="gt_row gt_center">0</td></tr>
    <tr><td headers="dimension" class="gt_row gt_left">16. Planificacin estratgica</td>
<td headers="valor" class="gt_row gt_center">0</td></tr>
    <tr><td headers="dimension" class="gt_row gt_left">17. Datos estadsticos</td>
<td headers="valor" class="gt_row gt_center">0</td></tr>
    <tr><td headers="dimension" class="gt_row gt_left">18. Metas</td>
<td headers="valor" class="gt_row gt_center">0</td></tr>
    <tr><td headers="dimension" class="gt_row gt_left">19. Informes de gestin</td>
<td headers="valor" class="gt_row gt_center">0</td></tr>
    <tr><td headers="dimension" class="gt_row gt_left">20. tem especfico por sujeto obligado</td>
<td headers="valor" class="gt_row gt_center">0</td></tr>
  </tbody>
  
  <tfoot class="gt_footnotes">
    <tr>
      <td class="gt_footnote" colspan="2"> Fuente: elaboracin propia en base a resultados IT</td>
    </tr>
  </tfoot>
</table>
</div>
</div>
<div id="recomendaciones" class="section level2 unnumbered">
<h2>Recomendaciones</h2>
<p>En virtud de los resultados obtenidos se detallan a continuacin una serie de recomendaciones para fortalecer la poltica de transparencia del organismo, en base al Instructivo para el cumplimiento de las obligaciones de Transparencia Activa y Proactiva por parte de los sujetos obligados de la Ley N 27.275 (Anexo I  Resolucin AAIP 77/2024):</p>
<ul>
<li>Recomendacin 1</li>
<li>Recomendacin 2</li>
<li>Recomendacin N</li>
</ul>
<blockquote>
<p>Las visualizaciones de los resultados del IT y los datasets se encuentran disponibles <a href="https://www.argentina.gob.ar/aaip/transparenciayparticipacion/indice-de-transparencia-activa">aqu</a>.</p>
</blockquote>
<div class="page-break-after"></div>
</div>
<div id="referencias" class="section level2 unnumbered">
<h2>Referencias</h2>
<ul>
<li><a href="https://servicios.infoleg.gob.ar/infolegInternet/anexos/265000-269999/265949/norma.htm">Ley N 27.275  Derecho de acceso a la informacin pblica</a></li>
<li><a href="https://www.argentina.gob.ar/normativa/nacional/resolucin-76-2024-397819">Resolucin AAIP 76/2024 - Pautas para la organizacin del Sistema de Transparencia y Acceso a la informacin publica</a></li>
<li><a href="https://www.argentina.gob.ar/normativa/nacional/resolucin-77-2024-397820">Resolucin AAIP 77/2024 - Instructivo para el cumplimiento de las obligaciones de Transparencia Activa y Proactiva por parte de los sujetos obligados de la Ley N 27.275 y Mecanismo de Monitoreo de las Polticas de Transparencia</a></li>
</ul>
</div>
</div>

<div class="back-cover">
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
